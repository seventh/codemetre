#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 2.3 (Thursday July 11th 2007) [Antoine-Auguste Parmentier]
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER F.MERIZEN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe -O3 -fomit-frame-pointer -funroll-loops -ffast-math
*/

/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.h) contains all basic Eiffel
  type definitions.
  This file is automatically included in the header for all modes of
  compilation: -boost, -no_check, -require_check, -ensure_check, ...
  This file is also included in the header of any cecil file (when the
  -cecil option is used).
  This file is also included in the header file of C++ wrappers (when
  using the external "C++" clause).
*/

#ifndef _BASE_H
#define _BASE_H

#if defined(_MSC_VER) && (_MSC_VER >= 1400)       /* VC8+ */
# ifndef _CRT_SECURE_NO_DEPRECATE
#  define _CRT_SECURE_NO_DEPRECATE
# endif
# ifndef _CRT_NONSTDC_NO_DEPRECATE
#  define _CRT_NONSTDC_NO_DEPRECATE
# endif
#endif   /* VC8+ */

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <signal.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <float.h>
#include <setjmp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  include <unistd.h>
#endif
#if !defined(WIN32) && \
       (defined(WINVER) || defined(_WIN32_WINNT) || defined(_WIN32) || \
	defined(__WIN32__) || defined(__TOS_WIN__) || defined(_MSC_VER))
#  define WIN32 1
#endif
#ifdef WIN32
#  include <windows.h>
#else
#  ifndef O_RDONLY
#    include <sys/file.h>
#  endif
#  ifndef O_RDONLY
#    define O_RDONLY 0000
#  endif
#endif

#if defined(_MSC_VER) && (_MSC_VER < 1500) /* MSVC older than v9 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "I64d"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c
#  define INT64_C(c) c ## i64
#elif defined(__WATCOMC__) && (__WATCOMC__ <= 1220) /* WATCOM 12.2 or lower */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__BORLANDC__) && (__BORLANDC__ < 0x600) /* Borland before 6.0 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "I64Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__FreeBSD__) && (__FreeBSD__ < 5) /* FreeBSD before 5.0 */ && !defined (_SYS_INTTYPES_H_)
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
#elif defined(__CYGWIN__) && defined(__BIT_TYPES_DEFINED__) /* Cygwin defines intxx_t in sys/types.h instead of inttypes.h */
#  include <cygwin/version.h>
#  if defined(CYGWIN_VERSION_DLL_MAJOR) && (CYGWIN_VERSION_DLL_MAJOR<1005)
typedef unsigned char uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
#  endif
#elif defined(SASC)
#    error("Too old SAS/C compiler, sorry.");
#elif defined(__SASC__)
#  if (__SASC__ < 750 ) /*  SAS/C before 7.50 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
#  endif
#else
#  include <inttypes.h>
#  if !defined(INT8_MAX) && defined(INT16_MAX)
/* int8_t is not mandatory */
typedef int_least8_t int8_t;
#  endif
#endif

#if !defined(PRId16)
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "lld"
#elif !defined(PRId8)
#  define PRId8 "d"
#endif
#if !defined(INT16_C)
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## LL
#elif !defined(INT8_C)
#  define INT8_C(c) c
#endif
#if !defined(INT16_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#  define INT8_MAX (INT8_C(127))
#  define INT16_MIN (-INT16_C(32767)-1)
#  define INT16_MAX (INT16_C(32767))
#  define INT32_MIN (-INT32_C(2147483647)-1)
#  define INT32_MAX (INT32_C(2147483647))
#  define INT64_MIN (-INT64_C(9223372036854775807)-1)
#  define INT64_MAX (INT64_C(9223372036854775807))
#elif !defined(INT8_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#endif


/*
  Endian stuff
*/
#if defined(BSD) && (BSD >= 199103)
#  include <machine/endian.h>
#elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
/* bi-endian processor, current mode should be find in machine/endian.h file */
#  include <machine/endian.h>
#elif defined(linux)
#  include <endian.h>
#endif



#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)
#  define BYTE_ORDER      __BYTE_ORDER
#endif

#if !defined(LITTLE_ENDIAN) && defined(__LITTLE_ENDIAN)
#  define LITTLE_ENDIAN      __LITTLE_ENDIAN
#endif

#if !defined(BIG_ENDIAN) && defined(__BIG_ENDIAN)
#  define BIG_ENDIAN      __BIG_ENDIAN
#endif

#if !defined(LITTLE_ENDIAN)
#  define LITTLE_ENDIAN   1234    /* LSB first (vax, pc) */
#endif
#if !defined(BIG_ENDIAN)
#  define BIG_ENDIAN      4321    /* MSB first (IBM, net) */
#endif
#if !defined(PDP_ENDIAN)
#  define PDP_ENDIAN      3412    /* LSB first in word, MSW first in long */
#endif

#if !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_RIGHT)
#  define BYTE_ORDER      LITTLE_ENDIAN
#elif !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_LEFT)
#  define BYTE_ORDER      BIG_ENDIAN
#elif !defined(BYTE_ORDER)

/* ARM */
#  if defined(__ARMEL__)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  elif defined(__ARMEB__)
#    define BYTE_ORDER      BIG_ENDIAN
#  elif defined(__arm__)
#    error "ARMs are bi-endian processors. Endianness is unknown for this system, please drop an e-mail to SmartEiffel@loria.fr"
#  endif

/* HP RISC */
#  if defined(__hppa__) || defined(__hppa) || defined(__hp9000) || \
      defined(__hp9000s300) || defined(hp9000s300) || \
      defined(__hp9000s700) || defined(hp9000s700) || \
      defined(__hp9000s800) || defined(hp9000s800) || defined(hp9000s820)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* IBM */
#  if defined(ibm032) || defined(ibm370) || defined(_IBMR2) || \
      defined(IBM370) || defined(__MVS__)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Intel x86 */
#  if defined(i386) || defined(__i386__) || defined(__i386) || \
      defined(_M_IX86) || defined(_X86_) || defined(__THW_INTEL) || \
      defined(sun386)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Intel Itanium */
#  if defined(__ia64__) || defined(_IA64) || defined(__IA64__) || \
      defined(_M_IA64)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Nationnal Semiconductor 32000 serie */
#  if  defined(ns32000)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Motorola 68000 */
#  if defined(mc68000) || defined(is68k) || defined(macII) || defined(m68k)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* MIPS */
#  if defined(MIPSEL) || defined(_MIPSEL)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  elif defined(MIPSEB) || defined(_MIPSEB)
#    define BYTE_ORDER      BIG_ENDIAN
#  elif defined(__mips__) || defined(__mips) || defined(__MIPS__)
#    error "MIPS are bi-endian processors. Endianness is unknown for this system, please drop an e-mail to SmartEiffel@loria.fr"
#  endif

/* Power PC */
/* this processor is bi-endian, how to know if little-endian is set? */
#  if defined(__powerpc) || defined(__powerpc__) || defined(__POWERPC__) || \
      defined(__ppc__) || defined(__ppc) || defined(_M_PPC) || \
      defined(__PPC) || defined(__PPC__)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Pyramid 9810 */
#  if defined(pyr)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* RS/6000 */
#  if defined(__THW_RS6000) || defined(_IBMR2) || defined(_POWER) || \
      defined(_ARCH_PWR) || defined(_ARCH_PWR2)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* SPARC */
#  if defined(__sparc__) || defined(sparc) || defined(__sparc)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* CCI Tahoe */
#  if defined(tahoe)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* VAX */
#  if defined(vax) || defined(VAX) || defined(__vax__) || defined(_vax_) || \
      defined(__vax) || defined(__VAX)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* ELATE is a virtual OS with a little endian Virtual Processor */
#  if defined(__ELATE__)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous little endian */
#  if defined(wrltitan)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous big endian */
#  if defined(apollo) || defined(__convex__) || defined(_CRAY) || defined(sel)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif
#endif


#if !defined(BYTE_ORDER)
#  error "Unknown byte order. Add your system in above macros once you know your system type. Please drop an e-mail to SmartEiffel@loria.fr"
#endif
#if (BYTE_ORDER != BIG_ENDIAN && BYTE_ORDER != LITTLE_ENDIAN)
#  error "Only little-endian and big-endian are valid at this time. Please drop an e-mail to SmartEiffel@loria.fr"
#endif


/*
  Byte swapping stuff
*/
extern void copy_swap_16(const uint16_t *src, uint16_t *dest, int count);


/* Because ANSI C EXIT_* are not always defined: */
#ifndef EXIT_FAILURE
#  define EXIT_FAILURE 1
#endif
#ifndef EXIT_SUCCESS
#  define EXIT_SUCCESS 0
#endif

/*
   On Linux glibc systems, we need to use sig.* versions of jmp_buf,
   setjmp and longjmp to preserve the signal handling context.
   Currently, the way I figured to detect this is if _SIGSET_H_types has
   been defined in /usr/include/setjmp.h.

   NOTE: with gcc, -ansi is used for SmartEiffel generated files EXCEPT in
   -no_split mode. ANSI only recognizes the non-sig versions.
*/
#if (defined(_SIGSET_H_types) && !defined(__STRICT_ANSI__))
#  define JMP_BUF    sigjmp_buf
#  define SETJMP(x)  sigsetjmp( (x), 1)
#  define LONGJMP    siglongjmp
#else
#  define JMP_BUF    jmp_buf
#  define SETJMP(x)  setjmp( (x) )
#  define LONGJMP    longjmp
#endif

/*
   Type to store reference objects Id:
 */
typedef int Tid;
typedef struct S0 T0;
struct S0{Tid id;};

/*
   The default channel used to print runtime error messages:
*/
#define SE_ERR stderr

/*
   Eiffel type INTEGER_8 is #1:
*/
typedef int8_t T1;
#define EIF_INTEGER_8 T1
#define M1 (INT8_C(0))
#define EIF_INTEGER_8_BITS (CHAR_BIT)
#define EIF_MINIMUM_INTEGER_8 (INT8_MIN)
#define EIF_MAXIMUM_INTEGER_8 (INT8_MAX)

/*
  Eiffel type INTEGER_16 is #10:
*/
typedef int16_t T10;
#define EIF_INTEGER_16 T10
#define M10 (INT16_C(0))
#define EIF_INTEGER_16_BITS (CHAR_BIT*sizeof(T10t))
#define EIF_MINIMUM_INTEGER_16 (INT16_MIN) /*-32768*/
#define EIF_MAXIMUM_INTEGER_16 (INT16_MAX) /*+32767*/

/*
  Eiffel type INTEGER or INTEGER_32 is #2:
*/
typedef int32_t T2;
#define EIF_INTEGER T2
#define EIF_INTEGER_32 T2
#define M2 (INT32_C(0))
#define EIF_INTEGER_BITS ((T2)(CHAR_BIT*sizeof(T2)))
#define EIF_INTEGER_32_BITS EIF_INTEGER_BITS
#define EIF_MINIMUM_INTEGER (INT32_MIN)
#define EIF_MAXIMUM_INTEGER (INT32_MAX)

/*
  Eiffel type INTEGER_64 is #11:
*/
typedef int64_t T11;
#define EIF_INTEGER_64 T11
#define M11 (INT64_C(0))
#define EIF_INTEGER_64_BITS (CHAR_BIT*sizeof(T11))
#define EIF_MINIMUM_INTEGER_64 (INT64_MIN)
#define EIF_MAXIMUM_INTEGER_64 (INT64_MAX)

/*
  Eiffel type CHARACTER is #3:
*/
typedef unsigned char T3;
#define EIF_CHARACTER T3
#define M3 (0)
#define EIF_CHARACTER_BITS (CHAR_BIT)
#define EIF_MINIMUM_CHARACTER_CODE (0)
#define EIF_MAXIMUM_CHARACTER_CODE (255)
#define T3code(x) ((T10)(x))
#define T3to_integer(x) ((signed char)(x))
#define T3to_integer_8(x) ((signed char)(x))
#define T3to_bit(x) (x)

/*
  Eiffel type REAL_32 is #4:
*/
typedef float T4;
typedef T4 real32_t;
#define EIF_REAL_32 T4
#define M4 (0.0)
#define EIF_MINIMUM_REAL_32 (-(FLT_MAX))
#define EIF_MAXIMUM_REAL_32 (FLT_MAX)

/*
  Eiffel type REAL or REAL_64 is #5:
*/
typedef double T5;
typedef T5 real64_t;
#define EIF_REAL_64 T5
#define M5 (0.0)
#define EIF_MINIMUM_REAL_64 (-(DBL_MAX))
#define EIF_MINIMUM_REAL (EIF_MINIMUM_REAL_64)
#define EIF_MAXIMUM_REAL_64 (DBL_MAX)
#define EIF_MAXIMUM_REAL (EIF_MAXIMUM_REAL_64)

/*
  Eiffel type REAL_EXTENDED is #12:
*/
typedef long double T12;
typedef T12 real_extended_t;
#define EIF_REAL_EXTENDED T12
#define M12 (0.0)
#define EIF_MINIMUM_REAL_EXTENDED (-(DBL_MAX))
#define EIF_MAXIMUM_REAL_EXTENDED (DBL_MAX)

/*
  Eiffel type BOOLEAN is #6:
*/
typedef char T6;
#define EIF_BOOLEAN T6
#define M6 (0)
#define EIF_BOOLEAN_BITS (CHAR_BIT)

/*
   Eiffel type POINTER is #8:
*/
typedef void* T8;
#define EIF_POINTER T8
/* Sometimes, NULL is defined as 0 */
#define M8 ((void*)NULL)
#define EIF_POINTER_BITS (CHAR_BIT*sizeof(void*))

/*
  To use type STRING on the C side:
*/
#define EIF_STRING T7*

/*
  Some Other EIF_* defined in ETL:
*/
#define eif_access(x) ((char*)(x))
#define EIF_REFERENCE T0*
#define EIF_OBJ T0*
#define EIF_OBJECT EIF_OBJ

/*
   Wrappers for `malloc' and `calloc':
*/
void* se_malloc(size_t size);
void* se_calloc(size_t nmemb, size_t size);
void* se_realloc(void* src, size_t size);

/*
   die method.
 */
void se_die(int code);

/*
    Runtime hooks. They allow different runtime modules to be quite independant. In time, they will also allow
    thread-safe operations.

    Currently known modules:
      - boost
      - no_check
      - sedb
      - gc
      - print stack
      - profile
      - plugins

    However, currently only profile uses this method. It will be extended to other modules later.

    The currently defined hooks are described in the enum below (the names should be self-explanatory).
 */
typedef enum {
  SE_HANDLE_EXCEPTION_SET, /* called when an exception handler is set, prior to SETJMP */
  SE_HANDLE_EXCEPTION_CLEAR, /* called when a feature with an exception handler normally returns */
  SE_HANDLE_EXCEPTION_THROWN, /* called when an exception is thrown, prior to the LONGJMP */
  SE_HANDLE_ENTER_GC, /* called when gc_start() begins */
  SE_HANDLE_EXIT_GC, /* called when gc_start() ends */
  SE_HANDLE_ENTER_PRINT_STACK, /* called when se_print_run_time_stack() begins */
  SE_HANDLE_EXIT_PRINT_STACK, /* called when se_print_run_time_stack() ends */
  SE_HANDLE_NO_MORE_MEMORY, /* called by se_alloc() and co */
  SE_HANDLE_SEDB_BREAK, /* called when sedb stops the program */
  SE_HANDLE_SEDB_CONTINUE, /* called when sedb continues the program */
  SE_HANDLE_RUNTIME_ERROR, /* called when a runtime error is raised and not caught by an exception. Cannot be raised in boost mode. */
  SE_HANDLE_DIE_WITH_CODE, /* called when the program is stopped by the die_with_code feature. The data points to the int code. */
  SE_HANDLE_NORMAL_EXIT /* called when the program correctly terminates. The data is null. */
} se_handler_action_t;

extern int handlers_count;
typedef void se_runtime_handler_t(se_handler_action_t action, void*data);
void register_handler(se_runtime_handler_t*handler);
void _handle(se_handler_action_t action, void*data);

#define handle(action,data) do{if(handlers_count>0)_handle(action,data);}while(0)

#endif /* #ifndef _BASE_H */
#define SE_BOOST 1
#define SE_GC_LIB 1
/* C Header Pass 1: */
typedef union _se_agent se_agent;
typedef struct _se_agent0 se_agent0;
typedef struct S237 T237;
typedef struct S236 T236;
typedef struct S73 T73;
typedef struct S234 T234;
typedef struct S141 T141;
typedef struct S230 T230;
typedef struct S187 T187;
typedef struct S182 T182;
typedef struct S146 T146;
typedef struct S143 T143;
typedef struct S225 T225;
typedef struct S222 T222;
typedef struct S226 T226;
typedef struct S224 T224;
typedef struct S223 T223;
typedef struct S221 T221;
typedef void*T191;
typedef struct S219 T219;
typedef void*T190;
typedef struct S217 T217;
typedef struct S142 T142;
typedef struct S209 T209;
typedef void*T157;
typedef struct S199 T199;
typedef struct S177 T177;
typedef struct S188 T188;
typedef struct S186 T186;
typedef struct S185 T185;
typedef struct S178 T178;
typedef struct S184 T184;
typedef struct S213 T213;
typedef struct S145 T145;
typedef struct S144 T144;
typedef struct S212 T212;
typedef struct S208 T208;
typedef struct S207 T207;
typedef struct S206 T206;
typedef struct S7 T7;
typedef int T203;
typedef struct S93 T93;
typedef struct S172 T172;
typedef struct S171 T171;
typedef struct S170 T170;
typedef struct S202 T202;
typedef struct S169 T169;
typedef struct S168 T168;
typedef int T94;
typedef struct S200 T200;
typedef struct S109 T109;
typedef void*T173;
typedef struct S97 T97;
typedef struct S197 T197;
typedef struct S49 T49;
typedef struct S112 T112;
typedef struct S195 T195;
typedef struct S120 T120;
typedef struct S119 T119;
typedef struct S118 T118;
typedef struct S117 T117;
typedef struct S74 T74;
typedef struct S116 T116;
typedef struct S114 T114;
typedef struct S175 T175;
typedef struct S148 T148;
typedef struct S59 T59;
typedef struct S102 T102;
typedef struct S57 T57;
typedef struct S174 T174;
typedef struct S51 T51;
typedef void*T39;
typedef T0 T193;
typedef struct S192 T192;
typedef struct S67 T67;
typedef void*T25;
/* C Header Pass 2: */
typedef T10*T238;
#define M238 NULL
typedef T2*T235;
#define M235 NULL
typedef T0**T232;
#define M232 NULL
typedef T0**T228;
#define M228 NULL
typedef T0**T227;
#define M227 NULL
typedef T0**T216;
#define M216 NULL
typedef T0**T215;
#define M215 NULL
typedef T0**T214;
#define M214 NULL
typedef T0**T211;
#define M211 NULL
typedef T0**T210;
#define M210 NULL
typedef T0**T205;
#define M205 NULL
typedef T0**T196;
#define M196 NULL
typedef T3*T9;
#define M9 NULL
/* C Header Pass 3: */
extern T203 M203;
struct S93{T8 _directory_stream;T8 _current_entry;} __attribute__((packed));
int se_cmpT93(T93 o1,T93 o2);
/* C Header Pass 4: */
struct S237{T235 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T237 M237;
struct S236{T238 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T236 M236;
struct S73{T238 _storage;T2 _count;T2 _capacity;T0* _low_surrogate_indexes;T0* _low_surrogate_values;} __attribute__((packed));
extern T73 M73;
struct S234{T235 _storage;T2 _capacity;T2 _upper;T2 _lower;} __attribute__((packed));
extern T234 M234;
struct S230{T232 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T230 M230;
struct S187{Tid id;T0* _path;T3 _drive;T0* _to_string_cache;T6 _valid_cache;} __attribute__((packed));
extern T187 M187;
struct S182{Tid id;T0* _to_string;} __attribute__((packed));
extern T182 M182;
struct S146{Tid id;T0* _filter;T0* _path;T11 _flushed_character_count;T9 _buffer;T2 _buffer_position;T2 _capacity;T8 _output_stream;} __attribute__((packed));
extern T146 M146;
struct S143{T0* _langage;T0* _nom;T0* _contenu;} __attribute__((packed));
extern T143 M143;
struct S226{T0* _arbre;T0* _couleur;T0* _pere;T0* _fils_gauche;T0* _fils_droite;T0* _etiquette;} __attribute__((packed));
extern T226 M226;
struct S225{T0* _arbre;T0* _noeud;} __attribute__((packed));
extern T225 M225;
struct S224{T228 _storage;T2 _capacity;T2 _upper;T2 _lower;} __attribute__((packed));
extern T224 M224;
struct S223{T0* _arbre;T0* _couleur;T0* _pere;T0* _fils_gauche;T0* _fils_droite;T0* _etiquette;} __attribute__((packed));
extern T223 M223;
struct S222{T0* _arbre;T0* _noeud;} __attribute__((packed));
extern T222 M222;
struct S221{T227 _storage;T2 _capacity;T2 _upper;T2 _lower;} __attribute__((packed));
extern T221 M221;
extern T191 M191;
struct S141{T0* _contenu;} __attribute__((packed));
extern T141 M141;
struct S219{T0* _ordre;T2 _nb_element;T0* _racine;T0* _nil;T0* _pointeurs;} __attribute__((packed));
extern T219 M219;
extern T190 M190;
struct S217{T0* _ordre;T2 _nb_element;T0* _racine;T0* _nil;T0* _pointeurs;} __attribute__((packed));
extern T217 M217;
extern T157 M157;
struct S177{Tid id;} __attribute__((packed));
extern T177 M177;
struct S188{Tid id;} __attribute__((packed));
extern T188 M188;
struct S186{Tid id;} __attribute__((packed));
extern T186 M186;
struct S185{Tid id;} __attribute__((packed));
extern T185 M185;
struct S178{Tid id;} __attribute__((packed));
extern T178 M178;
struct S184{Tid id;} __attribute__((packed));
extern T184 M184;
struct S213{T0* _item;} __attribute__((packed));
extern T213 M213;
struct S145{T6 _est_active_memoire;T0* _dico_ligne;T0* _dico_source;} __attribute__((packed));
extern T145 M145;
struct S144{T0* _fichier;T0* _tampon;T2 _indice;} __attribute__((packed));
extern T144 M144;
struct S142{T0* _lexeme;T6 _est_code;} __attribute__((packed));
extern T142 M142;
struct S212{T216 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T212 M212;
struct S209{T0* _item_1;T0* _item_2;} __attribute__((packed));
extern T209 M209;
struct S208{T215 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T208 M208;
struct S207{T0* _arbre;T0* _couleur;T0* _pere;T0* _fils_gauche;T0* _fils_droite;T0* _etiquette;} __attribute__((packed));
extern T207 M207;
struct S206{T214 _storage;T2 _capacity;T2 _upper;T2 _lower;} __attribute__((packed));
extern T206 M206;
extern T93 M93;
struct S172{Tid id;T6 _code_pris_en_compte;T6 _commentaire_pris_en_compte;T0* _fabrique;T0* _fichier;T0* _chaine;T0* _ligne;T0* _listage;T2 _indice_ligne;T6 _erreur;T0* _message_erreur;T0* _avant;T2 _etat;} __attribute__((packed));
extern T172 M172;
struct S171{Tid id;T6 _code_pris_en_compte;T6 _commentaire_pris_en_compte;T0* _fabrique;T0* _fichier;T0* _chaine;T0* _ligne;T0* _listage;T2 _indice_ligne;T6 _erreur;T0* _message_erreur;T0* _langage;T2 _etat;} __attribute__((packed));
extern T171 M171;
struct S170{Tid id;T6 _code_pris_en_compte;T6 _commentaire_pris_en_compte;T0* _fabrique;T0* _fichier;T0* _chaine;T0* _ligne;T0* _listage;T2 _indice_ligne;T6 _erreur;T0* _message_erreur;T2 _etat;T0* _chaine_litterale;} __attribute__((packed));
extern T170 M170;
struct S202{Tid id;T211 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T202 M202;
struct S169{Tid id;T2 _rajout;T2 _nouvel;} __attribute__((packed));
extern T169 M169;
struct S168{Tid id;T2 _a;T2 _n;T2 _c;} __attribute__((packed));
extern T168 M168;
extern T94 M94;
struct S200{Tid id;T210 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T200 M200;
struct S199{T0* _arbre;T0* _noeud;} __attribute__((packed));
extern T199 M199;
struct S109{T6 _est_ouvert;T2 _ligne;T2 _colonne;T0* _fichier;T0* _flux;T0* _associations;} __attribute__((packed));
extern T109 M109;
extern T173 M173;
struct S97{T0* _suffixe;T0* _langage;} __attribute__((packed));
extern T97 M97;
struct S197{T0* _ordre;T2 _nb_element;T0* _racine;T0* _nil;T0* _pointeurs;} __attribute__((packed));
extern T197 M197;
struct S49{Tid id;T2 _buffer_position;T9 _buffer;T2 _capacity;} __attribute__((packed));
extern T49 M49;
struct S112{Tid id;T0* _analyseur;T0* _nom_fichier;} __attribute__((packed));
extern T112 M112;
struct S195{T205 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T195 M195;
struct S120{Tid id;T0* _entree;T0* _entree_courte;T6 _est_epuise;T2 _lg_racine;T0* _fichiers;T2 _ligne;} __attribute__((packed));
extern T120 M120;
struct S119{Tid id;T0* _analyseur;T0* _nom_but;T0* _nom_nid;} __attribute__((packed));
extern T119 M119;
struct S118{Tid id;T0* _analyseur;T0* _nom_fichier;} __attribute__((packed));
extern T118 M118;
struct S117{Tid id;T0* _entree;T0* _flux;} __attribute__((packed));
extern T117 M117;
struct S74{T0* _filter;T0* _path;T6 _end_of_input;T3 _filtered_last_character;T8 _input_stream;T9 _buffer;T6 _end_reached;T2 _buffer_size;T2 _buffer_position;T2 _capacity;} __attribute__((packed));
extern T74 M74;
struct S116{Tid id;T0* _entree;T0* _entree_courte;} __attribute__((packed));
extern T116 M116;
struct S114{T0* _path;T6 _last_scan_status;T93 _basic_directory;T0* _name_list;} __attribute__((packed));
extern T114 M114;
struct S175{Tid id;} __attribute__((packed));
extern T175 M175;
struct S148{Tid id;T2 _instruction;T2 _commentaire;T2 _integralite;} __attribute__((packed));
extern T148 M148;
struct S59{T2 _nb_commandes_executees;T0* _metrique;} __attribute__((packed));
extern T59 M59;
struct S102{T6 _code;T6 _commentaire;T6 _total;} __attribute__((packed));
extern T102 M102;
struct S57{T6 _bilan_final_differentiel;T6 _bilan_final_unitaire;T0* _metrique;T0* _filtre_analyse;T0* _filtre_differentiel;T0* _filtre_unitaire;T6 _sortie_compacte;T0* _analyseur_force;T0* _associations;T6 _configuration_par_defaut;} __attribute__((packed));
extern T57 M57;
struct S174{Tid id;} __attribute__((packed));
extern T174 M174;
struct S51{T0* _default_message_catalog_directory;} __attribute__((packed));
extern T51 M51;
struct S7{T9 _storage;T2 _count;T2 _capacity;} __attribute__((packed));
extern T7 M7;
extern T39 M39;
struct S192{T196 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T192 M192;
struct S67{T0* _commandes;} __attribute__((packed));
extern T67 M67;
extern T25 M25;
extern char*s26_0;
extern char*s67_454460494;
extern char*s120_46;
extern char*s57_99;
extern char*s109_881684455;
extern char*s168_430693;
extern char*s143_190;
extern char*s118_200;
extern char*s57_207;
extern char*s118_237;
extern char*s57_252;
extern char*s142_166353;
extern char*s120_276;
extern char*s171_198117854;
extern char*s57_297;
extern char*s57_1914603628;
extern char*s67_322;
extern char*s57_329;
extern char*s57_331;
extern char*s57_334;
extern char*s119_363254;
extern char*s148_449372;
extern char*s168_357;
extern char*s168_367;
extern char*s67_1055124467;
extern char*s168_422;
extern char*s67_955293794;
extern char*s26_2030278;
extern char*s101_250303104;
extern char*s119_497;
extern char*s187_498;
extern char*s170_2117014773;
extern char*s67_1489194569;
extern char*s67_174479840;
extern char*s109_402183751;
extern char*s67_473806001;
extern char*s13_1432888418;
extern char*s143_21314053;
extern char*s67_1723129677;
extern char*s170_302894533;
extern char*s101_1469960689;
extern char*s170_1750975282;
extern char*s67_667384374;
extern char*s57_2067555065;
extern char*s57_1022;
extern char*s112_689122201;
extern char*s171_510417238;
extern char*s101_1122;
extern char*s57_367646412;
extern char*s67_184721825;
extern char*s119_1159;
extern char*s109_438530588;
extern char*s13_1210;
extern char*s57_1815775;
extern char*s171_509162564;
extern char*s170_896478796;
extern char*s57_338767662;
extern char*s57_1347;
extern char*s67_105509483;
extern char*s57_325069450;
extern char*s57_1130825850;
extern char*s170_1835982646;
extern char*s67_1426;
extern char*s119_1871339;
extern char*s67_678062;
extern char*s172_998148855;
extern char*s57_1636333591;
extern char*s170_156993542;
extern char*s67_1206126564;
extern char*s67_1823520895;
extern char*s170_1882109223;
extern char*s67_1652658481;
extern char*s67_212549485;
extern char*s170_1283315574;
extern char*s57_105374505;
extern char*s6_14036;
extern char*s57_1744;
extern char*s67_1511357824;
extern char*s57_1774;
extern char*s67_404817563;
extern char*s109_1655531153;
extern char*s112_482012695;
extern char*s67_709525889;
extern char*s172_1594537947;
extern char*s169_395586;
extern char*s171_1760805737;
extern char*s112_139149946;
extern char*s67_45085;
extern char*s25_866438147;
extern char*s171_2126858037;
extern char*s170_249419393;
extern char*s109_1933550935;
extern char*s57_8773;
extern char*s172_10797639;
extern char*s57_8790;
extern char*s172_727364563;
extern char*s148_9893487;
extern char*s57_778583985;
extern char*s57_2733;
extern char*s57_8897;
extern char*s57_1872750;
extern char*s171_155715434;
extern char*s57_9022;
extern char*s57_1015274632;
extern char*s57_72793912;
extern char*s183_1182938696;
extern char*s170_238286578;
extern char*s67_177674639;
extern char*s119_45440454;
extern char*s172_3022;
extern char*s67_494198994;
extern char*s57_575269189;
extern char*s57_1308013269;
extern char*s67_16967612;
extern char*s25_1860139408;
extern char*s172_141014885;
extern char*s172_619685758;
extern char*s67_402629279;
extern char*s170_1187496964;
extern char*s170_633654814;
extern char*s67_820749808;
extern char*s57_15751;
extern char*s169_1977962;
extern char*s170_397163;
extern char*s67_1209197973;
extern char*s170_2094708289;
extern char*s67_452763;
extern char*s57_89868;
extern char*s57_1326235;
extern char*s67_1679497459;
extern char*s6_59251;
extern char*s67_659784771;
extern char*s101_83912;
extern char*s57_1581702901;
extern char*s67_363423546;
extern char*s172_1916976;
extern char*s120_1839491374;
extern char*s57_155679758;
extern char*s57_1402518293;
extern char*s67_482439428;
extern char*s57_1978691;
extern char*s172_935023928;
extern char*s57_27714646;
extern char*s67_558072449;
extern char*s57_917949021;
extern char*s120_7613394;
extern char*s57_1945510587;
extern char*s57_2068456806;
extern char*s172_128695907;
extern char*s172_953440447;
extern char*s170_2038230808;
extern char*s171_276953473;
extern char*s57_78651488;
extern char*s59_127398187;
extern char*s25_1787719185;
extern char*s57_616531973;
extern char*s148_78787;
extern char*s171_2137071568;
extern char*s170_1077131282;
extern char*s67_1196995941;
extern char*s109_1519585192;
extern char*s170_613991936;
extern char*s171_39279407;
extern char*s57_11429;
extern char*s57_1387148262;
extern char*s57_1148145250;
extern char*s67_1689211819;
extern char*s171_806032802;
extern char*s170_1632850237;
extern char*s57_5787;
extern char*s57_20654818;
extern char*s51_49306196;
extern char*s67_1293198338;
extern char*s142_134522190;
extern char*s67_356856294;
extern char*s57_2022577931;
extern char*s57_70779537;
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#define SE_BOOST 1
void se_print_run_time_stack (void);
void se_signal_handler(int sig);
#define FSOC_SIZE 8192
#define RSOC_SIZE 32768
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
   This file (SmartEiffel/sys/runtime/gc_lib.h) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has
   been selected).
*/

#define SE_GC_LIB 1

#define SE_GC_LOW_MEMORY_STRATEGY 0
#define SE_GC_HIGH_MEMORY_STRATEGY 1
#define SE_GC_DEFAULT_MEMORY_STRATEGY 2
extern int se_gc_strategy;


#define RSOH_UNMARKED 15253
#define RSOH_FREE 1
#define RSOH_MARKED 2


#define FSOH_UNMARKED ((void *) 1)
#define FSOH_MARKED   ((void *) 2)

/* To codify the state and the type of some Memory Chunk, we are
   using the following definitions :
*/
#define FSO_FREE_CHUNK  (-2)
#define RSO_FREE_CHUNK  (-1)
#define RSO_USED_CHUNK  ( 0)
#define FSO_STORE_CHUNK ( 1)
#define FSO_USED_CHUNK  ( 2)
#define FREE_CHUNK(x) ((x)<0)

/* Minimum size for a store area in a ReSizable Objects Chunk :
 */
#define RSOC_MIN_STORE 512

/* The default channel used to print -gc_info flag information :
*/
#define SE_GCINFO SE_ERR

extern int collector_counter; /* MEMORY.collector_counter */

typedef struct s_mch mch; /* Memory Chunk Header. */
typedef struct s_fsoc fsoc; /* Fixed Size Objects Chunk. */
typedef union u_rsoh rsoh; /* ReSizable Object Header. */
typedef struct s_fll_rsoh fll_rsoh;
typedef struct s_rsoc rsoc; /* ReSizable Objects Chunk. */
typedef struct s_na_env na_env; /* Native Array ENVironment. */


struct s_mch{
  unsigned int size; /* In number of bytes (actual argument of malloc).*/
  int state_type; /* One value in : RSO_USED_CHUNK,
                     FREE_CHUNK, FSO_STORE_CHUNK, FSO_USED_CHUNK */
  void(*amfp)(mch*,void*); /* Align Mark Function Pointer. */
  void(*swfp)(mch*); /* SWeep Function Pointer. */
};

struct s_fsoc{
  mch header; /* Common header for fsoc and rsoc. */
  fsoc* next; /* The next one when in free list (fsocfl). */
  int count_minus_one;
  double first_object;
};

typedef struct _rso_header rso_header;

struct _rso_header{
    unsigned int size;
    int magic_flag;     /* RSOH_MARKED when used,
			   RSOH_FREE when free,
			   else RSOH_UNMARKED */
};

typedef union u_fso_header fso_header;

union u_fso_header{
  void* flag;
  void* next;/* accurately typed as gcXX* in actual fso headers */
};

union u_rsoh{
  rso_header header;
  double padding;
};

struct s_fll_rsoh {
  rso_header rsoh_field;
  fll_rsoh* nextflol;
};

struct s_rsoc{
  mch header; /* Common header for fsoc and rsoc. */
  unsigned int isize; /* Initial size (at malloc time) to detect split chunks. */
  rsoc* next; /* Next one when in free list (rsocfl) or in na_env->chunk_list. */
  fll_rsoh*free_list_of_large; /* Intra. free list. */
  na_env*nae;
  rsoh first_header;
};

struct s_na_env{
  unsigned int store_left;
  rsoh* store;
  rsoc*store_chunk;
  rsoc*chunk_list; /*List of chunks of that type that have a non-null free_list_of_large*/
  void (*gc_mark)(T0*);
  int space_used;
};

extern void**stack_bottom;
extern mch**gcmt;
extern int gcmt_max;
extern int gcmt_used;
extern int gc_is_off;
extern fsoc* fsocfl;
extern unsigned int fsoc_count;
extern unsigned int rsoc_count;
extern void*gcmt_tail_addr;

void gc_sweep(void);
void gc_mark(void* p);
mch* gc_find_chunk(void* p);
int gc_stack_size(void);
int garbage_delayed(void);
void gc_update_ceils(void);
char*new_na(na_env*nae,unsigned int size);
unsigned int fsocfl_count(void);
unsigned int rsocfl_count(void);
void gc_dispose_before_exit(void);
void mark_stack_and_registers (void);
fsoc* gc_fsoc_get1(void);
fsoc* gc_fsoc_get2(void);

int gc_memory_used(void);
/*The generic se_agent0 definition:*/
struct _se_agent0{
Tid id;
Tid creation_mold_id;
void(*afp)(se_agent*);void(*gc_mark_agent_mold)(se_agent*);
int(*eq)(se_agent*,se_agent*);
};
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#include <errno.h>

#define text_file_read_open(p) (fopen(((char*)(p)),"r"))
#define text_file_write_open(p) (fopen(((char*)(p)),"w"))
#define text_file_write_append(p) (fopen(((char*)(p)),"a"))
#define text_file_read_write_open(p) (fopen(((char*)(p)),"r+"))
#define text_file_read_write_append(p) (fopen(((char*)(p)),"a+"))
#define binary_file_read_open(p) (fopen(((char*)(p)),"rb"))
#define binary_file_write_open(p) (fopen(((char*)(p)),"wb"))
#define binary_file_write_append(p) (fopen(((char*)(p)),"ab"))
#define io_fclose(p) (fclose((FILE*)(p)))
#define io_flush(p) (fflush((FILE*)(p)))
#define io_getc(f) (getc(((FILE*)(f))))
#define io_putc(b, f) (putc((b),((FILE*)(f))))
#define io_fread(b, n, f) (fread((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define io_fwrite(b, n, f) (fwrite((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define io_feof(f) (feof(((FILE*)(f))))
#define io_rename(o, n) (rename(((char*)(o)),((char*)(n))))
#define io_remove(f) (remove(((char*)(f))))
#define io_fseek(f, o) (fseek((FILE*)(f),(o),SEEK_SET))
#define io_ftell(f) ((EIF_INTEGER_64)ftell((FILE*)(f)))

#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  define read_stdin(b, s) (read(STDIN_FILENO, b, s))
#else
   extern int read_stdin(EIF_CHARACTER *buffer, int size);
#endif

extern void io_copy(char*source, char*target);
extern int io_file_exists(char*source);
extern int io_same_physical_file(char*path1,char*path2);
#include <libintl.h>
#include <locale.h>
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#ifndef WIN32
#  include <dirent.h>
#endif
#ifndef WIN32
#  include <unistd.h>
#endif

EIF_POINTER directory_open(EIF_POINTER path);
EIF_POINTER directory_read_entry(EIF_POINTER dirstream);
EIF_POINTER directory_get_entry_name(EIF_POINTER entry);
EIF_BOOLEAN directory_close(EIF_POINTER dirstream);
#define directory_current_working_directory (directory_cwd())
EIF_POINTER directory_cwd(void);
EIF_BOOLEAN directory_chdir(EIF_POINTER destination);
EIF_BOOLEAN directory_mkdir(EIF_POINTER directory_path);
EIF_BOOLEAN directory_rmdir(EIF_POINTER directory_path);
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#define basic_getenv(v) (getenv((char*)v))
extern unsigned int fsoc_count_ceil;
extern unsigned int rsoc_count_ceil;
/*INTEGER_64*/T3 r11decimal_digit(T11 C);
/*INTEGER_64*/void r11append_in(T11 C,T0* a1);
/*BOOLEAN*/T0* r6to_string(T6 C);
/*BOOLEAN*/T6 r6_ix_and(T6 C,T6 a1);
/*BOOLEAN*/T6 r6_ix_or(T6 C,T6 a1);
/*BOOLEAN*/void r6append_in(T6 C,T0* a1);
extern T0*oBC64string_buffer;
extern int fBC64string_buffer;
/*INTEGER_32*/T0* r2string_buffer(void);
/*INTEGER_32*/T2 r2_ix_45(T2 C,T2 a1);
/*INTEGER_32*/T6 r2is_even(T2 C);
/*INTEGER_32*/T6 r2is_odd(T2 C);
/*INTEGER_32*/T6 r2in_range(T2 C,T2 a1,T2 a2);
/*INTEGER_32*/T2 r2min(T2 C,T2 a1);
/*INTEGER_32*/T2 r2max(T2 C,T2 a1);
/*INTEGER_32*/T3 r2decimal_digit(T2 C);
/*INTEGER_32*/T0* r2to_string(T2 C);
/*INTEGER_32*/void r2append_in(T2 C,T0* a1);
/*CHARACTER*/T6 r3_ix_6261(T3 C,T3 a1);
/*CHARACTER*/T6 r3_ix_60(T3 C,T3 a1);
/*CHARACTER*/T6 r3in_range(T3 C,T3 a1,T3 a2);
/*CHARACTER*/T6 r3_ix_6061(T3 C,T3 a1);
/*CHARACTER*/T1 r3decimal_value(T3 C);
/*CHARACTER*/T1 r3hexadecimal_value(T3 C);
/*CHARACTER*/T3 r3to_lower(T3 C);
/*NATIVE_ARRAY[INTEGER_16]*/T238 r238realloc(T238 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER_16]*/void r238copy_from(T238 C,T238 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER_16]*/void r238clear_all(T238 C,T2 a1);
/*NATIVE_ARRAY[INTEGER_32]*/T235 r235realloc(T235 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER_32]*/void r235copy_from(T235 C,T235 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER_32]*/T2 r235fast_index_of(T235 C,T2 a1,T2 a2,T2 a3);
/*NATIVE_ARRAY[INTEGER_32]*/void r235clear_all(T235 C,T2 a1);
/*NATIVE_ARRAY[INTEGER_32]*/void r235set_all_with(T235 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_LIGNE]*/T232 r232realloc(T232 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_LIGNE]*/void r232copy_from(T232 C,T232 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_LIGNE]*/void r232clear(T232 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_LIGNE]*/T6 r232fast_memcmp(T232 C,T232 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_LIGNE]*/void r232clear_all(T232 C,T2 a1);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/T228 r228realloc(T228 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r228copy_from(T228 C,T228 a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/T2 r228fast_first_index_of(T228 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r228clear_all(T228 C,T2 a1);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r228set_all_with(T228 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/T227 r227realloc(T227 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r227copy_from(T227 C,T227 a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/T2 r227fast_first_index_of(T227 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r227clear_all(T227 C,T2 a1);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r227set_all_with(T227 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[LUAT_SOURCE]*/T216 r216realloc(T216 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_SOURCE]*/void r216copy_from(T216 C,T216 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_SOURCE]*/void r216clear(T216 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_SOURCE]*/void r216clear_all(T216 C,T2 a1);
/*NATIVE_ARRAY[TUPLE[STRING,STRING]]*/T215 r215realloc(T215 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[TUPLE[STRING,STRING]]*/void r215copy_from(T215 C,T215 a1,T2 a2);
/*NATIVE_ARRAY[TUPLE[STRING,STRING]]*/void r215clear(T215 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[TUPLE[STRING,STRING]]*/void r215clear_all(T215 C,T2 a1);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/T214 r214realloc(T214 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r214copy_from(T214 C,T214 a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/T2 r214fast_first_index_of(T214 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r214clear_all(T214 C,T2 a1);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r214set_all_with(T214 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[LUAT_ANALYSEUR]*/T211 r211realloc(T211 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_ANALYSEUR]*/void r211copy_from(T211 C,T211 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_ANALYSEUR]*/void r211clear(T211 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_ANALYSEUR]*/void r211clear_all(T211 C,T2 a1);
/*NATIVE_ARRAY[LUAT_METRIQUE_DIFFERENTIEL]*/T210 r210realloc(T210 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_METRIQUE_DIFFERENTIEL]*/void r210copy_from(T210 C,T210 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_METRIQUE_DIFFERENTIEL]*/void r210clear(T210 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_METRIQUE_DIFFERENTIEL]*/void r210clear_all(T210 C,T2 a1);
/*NATIVE_ARRAY[STRING]*/T205 r205realloc(T205 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/void r205copy_from(T205 C,T205 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/void r205clear(T205 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/void r205clear_all(T205 C,T2 a1);
/*NATIVE_ARRAY[LUAT_COMMANDE]*/T196 r196realloc(T196 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_COMMANDE]*/void r196copy_from(T196 C,T196 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_COMMANDE]*/void r196clear(T196 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_COMMANDE]*/void r196clear_all(T196 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/T9 r9realloc(T9 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9copy_from(T9 C,T9 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9clear(T9 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9copy_at(T9 C,T2 a1,T9 a2,T2 a3);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9fast_memcmp(T9 C,T9 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9slice_copy(T9 C,T2 a1,T9 a2,T2 a3,T2 a4);
/*NATIVE_ARRAY[CHARACTER]*/T2 r9fast_reverse_index_of(T9 C,T3 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9clear_all(T9 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/void r9set_all_with(T9 C,T3 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9fast_has(T9 C,T3 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9remove_first(T9 C,T2 a1);
/*STRING*/T0* r7_ix_43(T7* C,T0* a1);
/*STRING*/T6 r7is_equal(T7* C,T0* a1);
/*STRING*/void r7append(T7* C,T0* a1);
/*STRING*/void r7copy(T7* C,T0* a1);
/*STRING*/void r7make_empty(T7* C);
/*STRING*/T6 r7has_suffix(T7* C,T0* a1);
/*STRING*/void r7remove_tail(T7* C,T2 a1);
/*STRING*/void r7make(T7* C,T2 a1);
/*STRING*/void r7append_string(T7* C,T0* a1);
/*STRING*/void r7make_filled(T7* C,T3 a1,T2 a2);
/*STRING*/T2 r7compare(T7* C,T0* a1);
/*STRING*/T0* r7twin(T7* C);
/*STRING*/T6 r7_ix_60(T7* C,T0* a1);
/*STRING*/void r7append_substring(T7* C,T0* a1,T2 a2,T2 a3);
/*STRING*/T6 r7_ix_6061(T7* C,T0* a1);
/*STRING*/void r7extend(T7* C,T3 a1);
/*STRING*/void r7remove_last(T7* C);
/*STRING*/T6 r7has(T7* C,T3 a1);
/*STRING*/void r7keep_head(T7* C,T2 a1);
/*STRING*/void r7append_character(T7* C,T3 a1);
/*STRING*/void r7fill_with(T7* C,T3 a1);
/*STRING*/void r7extend_unless(T7* C,T3 a1);
/*STRING*/void r7add_last(T7* C,T3 a1);
/*STRING*/void r7resize(T7* C,T2 a1);
/*STRING*/void r7ensure_capacity(T7* C,T2 a1);
/*STRING*/void r7to_lower(T7* C);
/*STRING*/void r7from_external_copy(T7* C,T8 a1);
/*STRING*/void r7from_external(T7* C,T8 a1);
/*STRING*/T8 r7to_external(T7* C);
/*STRING*/T2 r7last_index_of(T7* C,T3 a1);
/*STRING*/void r7with_capacity(T7* C,T2 a1);
/*STRING*/T6 r7is_boolean(T7* C);
/*STRING*/void r7remove_head(T7* C,T2 a1);
/*STRING*/T3 r7first(T7* C);
/*STRING*/void r7swap(T7* C,T2 a1,T2 a2);
/*STRING*/T3 r7last(T7* C);
/*STRING*/T6 r7valid_index(T7* C,T2 a1);
/*STRING*/T0* r7substring(T7* C,T2 a1,T2 a2);
/*STRING*/T6 r7to_boolean(T7* C);
/*STRING*/T2 r7reverse_index_of(T7* C,T3 a1,T2 a2);
/*STRING*/void r7keep_tail(T7* C,T2 a1);
/*STRING*/void r7remove_first(T7* C);
/*STRING*/void r7put(T7* C,T3 a1,T2 a2);
/*STRING*/void r7remove_between(T7* C,T2 a1,T2 a2);
/*FAST_ARRAY[INTEGER_32]*/void r237make(T237* C,T2 a1);
/*FAST_ARRAY[INTEGER_32]*/void r237add_last(T237* C,T2 a1);
/*FAST_ARRAY[INTEGER_32]*/T2 r237fast_first_index_of(T237* C,T2 a1);
/*FAST_ARRAY[INTEGER_16]*/void r236make(T236* C,T2 a1);
/*FAST_ARRAY[INTEGER_16]*/void r236add_last(T236* C,T10 a1);
/*ARRAY[INTEGER_32]*/void r234make(T234* C,T2 a1,T2 a2);
/*ARRAY[INTEGER_32]*/void r234ensure_capacity_and_bounds(T234* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[INTEGER_32]*/T2 r234last(T234* C);
/*ARRAY[INTEGER_32]*/T2 r234item(T234* C,T2 a1);
/*ARRAY[INTEGER_32]*/void r234clear_all(T234* C);
/*ARRAY[INTEGER_32]*/void r234set_all_with(T234* C,T2 a1);
/*ARRAY[INTEGER_32]*/void r234put(T234* C,T2 a1,T2 a2);
/*FAST_ARRAY[LUAT_LIGNE]*/T6 r230is_equal(T230* C,T0* a1);
/*FAST_ARRAY[LUAT_LIGNE]*/void r230add_last(T230* C,T0* a1);
/*FAST_ARRAY[LUAT_LIGNE]*/void r230with_capacity(T230* C,T2 a1);
/*FAST_ARRAY[LUAT_LIGNE]*/void r230mark_native_arrays(T230* C);
/*FAST_ARRAY[LUAT_LIGNE]*/T2 r230count(T230* C);
/*FAST_ARRAY[LUAT_LIGNE]*/T0* r230item(T230* C,T2 a1);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r224remove_last(T224* C);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r224add_last(T224* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r224ensure_capacity_and_bounds(T224* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r224with_capacity(T224* C,T2 a1,T2 a2);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r224mark_native_arrays(T224* C);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/T2 r224count(T224* C);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/T0* r224last(T224* C);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/T2 r224fast_first_index_of(T224* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/T0* r224item(T224* C,T2 a1);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r224clear_all(T224* C);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r224set_all_with(T224* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r224put(T224* C,T0* a1,T2 a2);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r221remove_last(T221* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r221add_last(T221* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r221ensure_capacity_and_bounds(T221* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r221with_capacity(T221* C,T2 a1,T2 a2);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r221mark_native_arrays(T221* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/T2 r221count(T221* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/T0* r221last(T221* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/T2 r221fast_first_index_of(T221* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/T0* r221item(T221* C,T2 a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r221clear_all(T221* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r221set_all_with(T221* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r221put(T221* C,T0* a1,T2 a2);
/*FAST_ARRAY[LUAT_SOURCE]*/void r212add_last(T212* C,T0* a1);
/*FAST_ARRAY[LUAT_SOURCE]*/void r212with_capacity(T212* C,T2 a1);
/*FAST_ARRAY[LUAT_SOURCE]*/void r212mark_native_arrays(T212* C);
/*FAST_ARRAY[LUAT_SOURCE]*/T2 r212count(T212* C);
/*FAST_ARRAY[LUAT_SOURCE]*/T6 r212is_empty(T212* C);
/*FAST_ARRAY[LUAT_SOURCE]*/T0* r212item(T212* C,T2 a1);
/*FAST_ARRAY[TUPLE[STRING,STRING]]*/void r208add_last(T208* C,T0* a1);
/*FAST_ARRAY[TUPLE[STRING,STRING]]*/void r208with_capacity(T208* C,T2 a1);
/*FAST_ARRAY[TUPLE[STRING,STRING]]*/void r208mark_native_arrays(T208* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r206remove_last(T206* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r206add_last(T206* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r206ensure_capacity_and_bounds(T206* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r206with_capacity(T206* C,T2 a1,T2 a2);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r206mark_native_arrays(T206* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/T2 r206count(T206* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/T0* r206last(T206* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/T2 r206fast_first_index_of(T206* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/T0* r206item(T206* C,T2 a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r206clear_all(T206* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r206set_all_with(T206* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r206put(T206* C,T0* a1,T2 a2);
/*FAST_ARRAY[LUAT_ANALYSEUR]*/void r202add_last(T202* C,T0* a1);
/*FAST_ARRAY[LUAT_ANALYSEUR]*/void r202with_capacity(T202* C,T2 a1);
/*FAST_ARRAY[LUAT_ANALYSEUR]*/void r202mark_native_arrays(T202* C);
/*FAST_ARRAY[LUAT_ANALYSEUR]*/T6 r202valid_index(T202* C,T2 a1);
/*FAST_ARRAY[LUAT_ANALYSEUR]*/T0* r202item(T202* C,T2 a1);
/*FAST_ARRAY[LUAT_METRIQUE_DIFFERENTIEL]*/void r200add_last(T200* C,T0* a1);
/*FAST_ARRAY[LUAT_METRIQUE_DIFFERENTIEL]*/void r200with_capacity(T200* C,T2 a1);
/*FAST_ARRAY[LUAT_METRIQUE_DIFFERENTIEL]*/void r200mark_native_arrays(T200* C);
/*FAST_ARRAY[LUAT_METRIQUE_DIFFERENTIEL]*/T6 r200valid_index(T200* C,T2 a1);
/*FAST_ARRAY[LUAT_METRIQUE_DIFFERENTIEL]*/T0* r200item(T200* C,T2 a1);
/*FAST_ARRAY[STRING]*/void r195make(T195* C,T2 a1);
/*FAST_ARRAY[STRING]*/void r195remove_last(T195* C);
/*FAST_ARRAY[STRING]*/void r195add_last(T195* C,T0* a1);
/*FAST_ARRAY[STRING]*/void r195with_capacity(T195* C,T2 a1);
/*FAST_ARRAY[STRING]*/void r195mark_native_arrays(T195* C);
/*FAST_ARRAY[STRING]*/void r195swap(T195* C,T2 a1,T2 a2);
/*FAST_ARRAY[STRING]*/T6 r195valid_index(T195* C,T2 a1);
/*FAST_ARRAY[STRING]*/T6 r195is_empty(T195* C);
/*FAST_ARRAY[STRING]*/T0* r195item(T195* C,T2 a1);
/*FAST_ARRAY[STRING]*/void r195put(T195* C,T0* a1,T2 a2);
/*FAST_ARRAY[LUAT_COMMANDE]*/void r192add_last(T192* C,T0* a1);
/*FAST_ARRAY[LUAT_COMMANDE]*/void r192with_capacity(T192* C,T2 a1);
/*FAST_ARRAY[LUAT_COMMANDE]*/void r192mark_native_arrays(T192* C);
/*FAST_ARRAY[LUAT_COMMANDE]*/T6 r192is_empty(T192* C);
/*FAST_ARRAY[LUAT_COMMANDE]*/T0* r192item(T192* C,T2 a1);
/*FAST_ARRAY[LUAT_COMMANDE]*/void r192do_all(T192* C,T0* a1);
/*ARN_NOEUD[LUAT_LIGNE]*/void r226fabriquer_nil(T226* C,T0* a1);
/*ARN_NOEUD[LUAT_LIGNE]*/void r226initialiser_nil(T226* C);
/*ARN_NOEUD[LUAT_LIGNE]*/void r226fabriquer(T226* C,T0* a1);
/*ARN_NOEUD[LUAT_LIGNE]*/void r226initialiser(T226* C);
/*ARN_ITERATEUR[LUAT_LIGNE]*/void r225pointer_hors_borne(T225* C);
/*ARN_ITERATEUR[LUAT_LIGNE]*/T6 r225est_hors_borne(T225* C);
/*ARN_ITERATEUR[LUAT_LIGNE]*/void r225detacher(T225* C);
/*ARN_ITERATEUR[LUAT_LIGNE]*/void r225attacher(T225* C,T0* a1);
/*ARN_NOEUD[LUAT_SOURCE]*/void r223fabriquer_nil(T223* C,T0* a1);
/*ARN_NOEUD[LUAT_SOURCE]*/void r223initialiser_nil(T223* C);
/*ARN_NOEUD[LUAT_SOURCE]*/void r223fabriquer(T223* C,T0* a1);
/*ARN_NOEUD[LUAT_SOURCE]*/void r223initialiser(T223* C);
/*ARN_ITERATEUR[LUAT_SOURCE]*/void r222pointer_hors_borne(T222* C);
/*ARN_ITERATEUR[LUAT_SOURCE]*/T6 r222est_hors_borne(T222* C);
/*ARN_ITERATEUR[LUAT_SOURCE]*/void r222detacher(T222* C);
/*ARN_ITERATEUR[LUAT_SOURCE]*/void r222attacher(T222* C,T0* a1);
/*ARN_ARBRE[LUAT_LIGNE]*/void r219i_inserer(T219* C,T0* a1);
/*ARN_ARBRE[LUAT_LIGNE]*/void r219fabriquer(T219* C,T0* a1);
/*ARN_ARBRE[LUAT_LIGNE]*/void r219ajouter(T219* C,T0* a1);
/*ARN_ARBRE[LUAT_LIGNE]*/void r219vider(T219* C);
/*ARN_ARBRE[LUAT_LIGNE]*/void r219trouver(T219* C,T0* a1,T0* a2);
/*ARN_ARBRE[LUAT_LIGNE]*/T6 r219est_vide(T219* C);
/*ARN_ARBRE[LUAT_LIGNE]*/T0* r219i_trouver(T219* C,T0* a1);
/*ARN_ARBRE[LUAT_LIGNE]*/void r219oublier(T219* C,T0* a1);
/*ARN_ARBRE[LUAT_LIGNE]*/void r219rotation_droite(T219* C,T0* a1);
/*ARN_ARBRE[LUAT_LIGNE]*/void r219rotation_gauche(T219* C,T0* a1);
/*ARN_ARBRE[LUAT_SOURCE]*/void r217i_inserer(T217* C,T0* a1);
/*ARN_ARBRE[LUAT_SOURCE]*/void r217fabriquer(T217* C,T0* a1);
/*ARN_ARBRE[LUAT_SOURCE]*/void r217ajouter(T217* C,T0* a1);
/*ARN_ARBRE[LUAT_SOURCE]*/void r217vider(T217* C);
/*ARN_ARBRE[LUAT_SOURCE]*/void r217trouver(T217* C,T0* a1,T0* a2);
/*ARN_ARBRE[LUAT_SOURCE]*/T6 r217est_vide(T217* C);
/*ARN_ARBRE[LUAT_SOURCE]*/T0* r217i_trouver(T217* C,T0* a1);
/*ARN_ARBRE[LUAT_SOURCE]*/void r217oublier(T217* C,T0* a1);
/*ARN_ARBRE[LUAT_SOURCE]*/void r217rotation_droite(T217* C,T0* a1);
/*ARN_ARBRE[LUAT_SOURCE]*/void r217rotation_gauche(T217* C,T0* a1);
T209*create209make_2(T0* a1,T0* a2);
/*TUPLE[STRING,STRING]*/void r209make_2(T209* C,T0* a1,T0* a2);
/*ARN_NOEUD[LUAT_SUFFIXE]*/void r207fabriquer_nil(T207* C,T0* a1);
/*ARN_NOEUD[LUAT_SUFFIXE]*/T0* r207minimum(T207* C);
/*ARN_NOEUD[LUAT_SUFFIXE]*/void r207initialiser_nil(T207* C);
/*ARN_NOEUD[LUAT_SUFFIXE]*/void r207fabriquer(T207* C,T0* a1);
/*ARN_NOEUD[LUAT_SUFFIXE]*/void r207initialiser(T207* C);
/*ARN_NOEUD[LUAT_SUFFIXE]*/T0* r207successeur(T207* C);
/*COLLECTION_SORTER[STRING]*/void r203quick_sort(T0* a1);
/*COLLECTION_SORTER[STRING]*/T6 r203lt(T0* a1,T0* a2);
/*COLLECTION_SORTER[STRING]*/void r203sort(T0* a1);
/*COLLECTION_SORTER[STRING]*/T6 r203lte(T0* a1,T0* a2);
/*COLLECTION_SORTER[STRING]*/void r203quick_sort_region(T0* a1,T2 a2,T2 a3);
/*COLLECTION_SORTER[STRING]*/T6 r203is_sorted(T0* a1);
/*ARN_ITERATEUR[LUAT_SUFFIXE]*/void r199pointer_hors_borne(T199* C);
/*ARN_ITERATEUR[LUAT_SUFFIXE]*/void r199pointer_premier(T199* C);
/*ARN_ITERATEUR[LUAT_SUFFIXE]*/T6 r199est_hors_borne(T199* C);
/*ARN_ITERATEUR[LUAT_SUFFIXE]*/void r199avancer(T199* C);
/*ARN_ITERATEUR[LUAT_SUFFIXE]*/void r199detacher(T199* C);
/*ARN_ITERATEUR[LUAT_SUFFIXE]*/void r199attacher(T199* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r197i_inserer(T197* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r197fabriquer(T197* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r197ajouter(T197* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r197retirer(T197* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r197trouver(T197* C,T0* a1,T0* a2);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r197deplacer(T197* C,T0* a1,T0* a2);
/*ARN_ARBRE[LUAT_SUFFIXE]*/T0* r197i_trouver(T197* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r197oublier(T197* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r197rotation_droite(T197* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r197reformer(T197* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r197rotation_gauche(T197* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r197i_retirer(T197* C,T0* a1);
/*UNICODE_STRING*/void r73make_empty(T73* C);
/*UNICODE_STRING*/void r73make(T73* C,T2 a1);
/*UNICODE_STRING*/void r73clear_count(T73* C);
/*UNICODE_STRING*/T6 r73valid_unicode(T2 a1);
/*UNICODE_STRING*/T10 r73low_surrogate_value(T73* C,T2 a1);
/*UNICODE_STRING*/void r73utf8_encode_in(T73* C,T0* a1);
/*UNICODE_STRING*/void r73add_last(T73* C,T2 a1);
/*UNICODE_STRING*/T2 r73item(T73* C,T2 a1);
/*MICROSOFT_PATH_NAME*/void r187make_from_string(T187* C,T0* a1);
/*MICROSOFT_PATH_NAME*/void r187make_empty(T187* C);
/*MICROSOFT_PATH_NAME*/void r187join_up(T187* C);
/*MICROSOFT_PATH_NAME*/void r187start_join(T187* C,T0* a1,T2 a2);
/*MICROSOFT_PATH_NAME*/void r187remove_last(T187* C);
/*MICROSOFT_PATH_NAME*/void r187end_join(T187* C);
/*MICROSOFT_PATH_NAME*/void r187join_element(T187* C,T0* a1);
/*MICROSOFT_PATH_NAME*/void r187join_directory(T187* C,T0* a1);
/*MICROSOFT_PATH_NAME*/void r187add_last(T187* C,T0* a1);
/*MICROSOFT_PATH_NAME*/T6 r187is_separator(T3 a1);
/*MICROSOFT_PATH_NAME*/T0* r187drive_specification(T187* C);
/*MICROSOFT_PATH_NAME*/T6 r187is_absolute(T187* C);
/*MICROSOFT_PATH_NAME*/void r187go_up(T187* C);
/*MICROSOFT_PATH_NAME*/void r187make_current(T187* C);
/*MICROSOFT_PATH_NAME*/void r187join_to(T187* C,T0* a1);
/*MICROSOFT_PATH_NAME*/void r187join(T187* C,T0* a1);
/*MICROSOFT_PATH_NAME*/T0* r187to_string(T187* C);
/*MICROSOFT_PATH_NAME*/void r187make_root(T187* C);
/*MICROSOFT_PATH_NAME*/void r187join_directory_to(T0* a1,T0* a2);
/*MICROSOFT_PATH_NAME*/T2 r187count(T187* C);
/*MICROSOFT_PATH_NAME*/void r187join_element_to(T0* a1,T0* a2);
/*MICROSOFT_PATH_NAME*/T2 r187start_join_to(T187* C,T0* a1);
/*MICROSOFT_PATH_NAME*/T2 r187scan_element(T187* C,T2 a1,T0* a2);
/*MICROSOFT_PATH_NAME*/T0* r187last(T187* C);
/*MICROSOFT_PATH_NAME*/void r187_P_183_join_element(T187* C,T0* a1);
/*MICROSOFT_PATH_NAME*/void r187_P_181_end_join(T187* C);
/*POSIX_PATH_NAME*/void r182make_from_string(T182* C,T0* a1);
/*POSIX_PATH_NAME*/void r182make_empty(T182* C);
/*POSIX_PATH_NAME*/void r182join_up(T182* C);
/*POSIX_PATH_NAME*/void r182start_join(T182* C,T0* a1,T2 a2);
/*POSIX_PATH_NAME*/void r182remove_last(T182* C);
/*POSIX_PATH_NAME*/void r182end_join(T182* C);
/*POSIX_PATH_NAME*/void r182join_element(T182* C,T0* a1);
/*POSIX_PATH_NAME*/void r182join_directory(T182* C,T0* a1);
/*POSIX_PATH_NAME*/void r182add_last(T182* C,T0* a1);
/*POSIX_PATH_NAME*/T6 r182is_separator(T3 a1);
/*POSIX_PATH_NAME*/T6 r182is_absolute(T182* C);
/*POSIX_PATH_NAME*/void r182go_up(T182* C);
/*POSIX_PATH_NAME*/void r182make_current(T182* C);
/*POSIX_PATH_NAME*/void r182join_to(T182* C,T0* a1);
/*POSIX_PATH_NAME*/void r182join(T182* C,T0* a1);
/*POSIX_PATH_NAME*/void r182make_root(T182* C);
/*POSIX_PATH_NAME*/void r182join_directory_to(T0* a1,T0* a2);
/*POSIX_PATH_NAME*/T2 r182count(T182* C);
/*POSIX_PATH_NAME*/void r182join_element_to(T0* a1,T0* a2);
/*POSIX_PATH_NAME*/T2 r182start_join_to(T182* C,T0* a1);
/*POSIX_PATH_NAME*/T2 r182scan_element(T182* C,T2 a1,T0* a2);
/*POSIX_PATH_NAME*/T0* r182last(T182* C);
/*TEXT_FILE_WRITE*/void r146connect_to(T146* C,T0* a1);
/*TEXT_FILE_WRITE*/void r146filtered_put_character(T146* C,T3 a1);
/*TEXT_FILE_WRITE*/void r146write_buffer(T146* C);
/*TEXT_FILE_WRITE*/void r146disconnect(T146* C);
/*TEXT_FILE_WRITE*/void r146put_character(T146* C,T3 a1);
/*TEXT_FILE_WRITE*/void r146put_string(T146* C,T0* a1);
/*TEXT_FILE_WRITE*/void r146put_integer(T146* C,T11 a1);
extern T0*oBC32tmp_string;
extern int fBC32tmp_string;
/*TEXT_FILE_WRITE*/T0* r146tmp_string(void);
/*TEXT_FILE_WRITE*/void r146put_spaces(T146* C,T2 a1);
/*TEXT_FILE_WRITE*/void r146put_new_line(T146* C);
/*LUAT_LISTAGE*/void r143fabriquer(T143* C,T0* a1,T0* a2);
/*LUAT_LISTAGE*/T2 r143nb_ligne(T143* C);
/*LUAT_LISTAGE*/T2 r143nb_ligne_code(T143* C);
/*LUAT_LISTAGE*/T6 r143est_equivalent(T143* C,T0* a1);
/*LUAT_LISTAGE*/T2 r143nb_ligne_commentaire(T143* C);
/*LUAT_LISTAGE*/void r143afficher(T143* C,T0* a1);
T191*create191(void);
/*LUAT_ORDRE_LIGNE*/T6 r191est_verifie(T0* a1,T0* a2);
/*LUAT_ORDRE_LIGNE*/T2 r191trichotomie(T0* a1,T0* a2);
extern T0*oBC191ordre_source;
/*LUAT_LIGNE*/T2 r141nb_element(T141* C);
/*LUAT_LIGNE*/T0* r141element(T141* C,T2 a1);
/*LUAT_LIGNE*/void r141fabriquer(T141* C,T0* a1);
/*LUAT_LIGNE*/T6 r141contient_commentaire(T141* C);
/*LUAT_LIGNE*/T6 r141contient_code(T141* C);
/*LUAT_LIGNE*/void r141afficher(T141* C,T0* a1);
T190*create190(void);
/*LUAT_ORDRE_SOURCE*/T6 r190est_verifie(T0* a1,T0* a2);
/*LUAT_ORDRE_SOURCE*/T2 r190trichotomie(T0* a1,T0* a2);
T177*create177(void);
extern T0*oBC13std_error;
/*MACINTOSH_DIRECTORY_NOTATION*/void r177crash(T177* C);
/*MACINTOSH_DIRECTORY_NOTATION*/void r177not_yet_implemented(T177* C);
/*MACINTOSH_DIRECTORY_NOTATION*/T6 r177respects_repertory_notation(T0* a1);
/*MACINTOSH_DIRECTORY_NOTATION*/void r177spell_as_repertory(T0* a1);
/*MACINTOSH_DIRECTORY_NOTATION*/void r177to_directory_path(T0* a1);
/*MACINTOSH_DIRECTORY_NOTATION*/void r177to_absolute_path_in(T177* C,T0* a1,T0* a2);
/*MACINTOSH_DIRECTORY_NOTATION*/void r177to_subpath_with(T0* a1,T0* a2);
/*MACINTOSH_DIRECTORY_NOTATION*/T6 r177is_absolute_path(T177* C,T0* a1);
T188*create188(void);
/*CYGWIN_DIRECTORY_NOTATION*/T6 r188respects_repertory_notation(T0* a1);
/*CYGWIN_DIRECTORY_NOTATION*/void r188spell_as_repertory(T0* a1);
/*CYGWIN_DIRECTORY_NOTATION*/void r188to_directory_path(T0* a1);
/*CYGWIN_DIRECTORY_NOTATION*/void r188to_absolute_path_in(T0* a1,T0* a2);
/*CYGWIN_DIRECTORY_NOTATION*/void r188to_subpath_with(T0* a1,T0* a2);
/*CYGWIN_DIRECTORY_NOTATION*/T6 r188is_absolute_path(T0* a1);
T186*create186(void);
extern T0*oBC186tmp1;
extern int fBC186tmp1;
/*WINDOWS_DIRECTORY_NOTATION*/T0* r186tmp1(void);
/*WINDOWS_DIRECTORY_NOTATION*/T6 r186respects_repertory_notation(T0* a1);
extern T0*oBC186tmp2;
extern int fBC186tmp2;
/*WINDOWS_DIRECTORY_NOTATION*/T0* r186tmp2(void);
/*WINDOWS_DIRECTORY_NOTATION*/void r186spell_as_repertory(T0* a1);
/*WINDOWS_DIRECTORY_NOTATION*/void r186to_directory_path(T0* a1);
/*WINDOWS_DIRECTORY_NOTATION*/void r186to_absolute_path_in(T0* a1,T0* a2);
/*WINDOWS_DIRECTORY_NOTATION*/void r186to_subpath_with(T0* a1,T0* a2);
/*WINDOWS_DIRECTORY_NOTATION*/T6 r186is_absolute_path(T0* a1);
T185*create185(void);
/*AMIGA_DIRECTORY_NOTATION*/void r185crash(T185* C);
/*AMIGA_DIRECTORY_NOTATION*/void r185not_yet_implemented(T185* C);
/*AMIGA_DIRECTORY_NOTATION*/T6 r185respects_repertory_notation(T0* a1);
/*AMIGA_DIRECTORY_NOTATION*/void r185spell_as_repertory(T0* a1);
/*AMIGA_DIRECTORY_NOTATION*/void r185to_directory_path(T0* a1);
/*AMIGA_DIRECTORY_NOTATION*/void r185to_absolute_path_in(T185* C,T0* a1,T0* a2);
/*AMIGA_DIRECTORY_NOTATION*/void r185to_subpath_with(T0* a1,T0* a2);
/*AMIGA_DIRECTORY_NOTATION*/T6 r185is_absolute_path(T185* C,T0* a1);
T178*create178(void);
extern T0*oBC178tmp1;
extern int fBC178tmp1;
/*UNIX_DIRECTORY_NOTATION*/T0* r178tmp1(void);
/*UNIX_DIRECTORY_NOTATION*/T6 r178respects_repertory_notation(T0* a1);
extern T0*oBC178tmp2;
extern int fBC178tmp2;
/*UNIX_DIRECTORY_NOTATION*/T0* r178tmp2(void);
/*UNIX_DIRECTORY_NOTATION*/void r178spell_as_repertory(T0* a1);
/*UNIX_DIRECTORY_NOTATION*/void r178to_directory_path(T0* a1);
/*UNIX_DIRECTORY_NOTATION*/void r178to_absolute_path_in(T0* a1,T0* a2);
/*UNIX_DIRECTORY_NOTATION*/void r178to_subpath_with(T0* a1,T0* a2);
/*UNIX_DIRECTORY_NOTATION*/T6 r178is_absolute_path(T0* a1);
T184*create184(void);
/*OPENVMS_DIRECTORY_NOTATION*/void r184crash(T184* C);
/*OPENVMS_DIRECTORY_NOTATION*/void r184not_yet_implemented(T184* C);
/*OPENVMS_DIRECTORY_NOTATION*/T6 r184respects_repertory_notation(T0* a1);
/*OPENVMS_DIRECTORY_NOTATION*/void r184to_directory_path(T184* C,T0* a1);
/*OPENVMS_DIRECTORY_NOTATION*/void r184to_absolute_path_in(T184* C,T0* a1,T0* a2);
/*OPENVMS_DIRECTORY_NOTATION*/void r184to_subpath_with(T184* C,T0* a1,T0* a2);
/*OPENVMS_DIRECTORY_NOTATION*/T6 r184is_absolute_path(T184* C,T0* a1);
/*LUAT_FABRIQUE*/T0* r145produire_commentaire(T145* C,T0* a1);
/*LUAT_FABRIQUE*/T0* r145produire_ligne(T145* C,T0* a1);
/*LUAT_FABRIQUE*/void r145reinitialiser(T145* C);
/*LUAT_FABRIQUE*/void r145fabriquer(T145* C);
/*LUAT_FABRIQUE*/T0* r145produire_code(T145* C,T0* a1);
/*LUAT_ENTREE*/void r144fabriquer(T144* C);
/*LUAT_ENTREE*/T3 r144caractere(T144* C);
/*LUAT_ENTREE*/void r144initialiser(T144* C,T0* a1);
/*LUAT_ENTREE*/void r144terminer(T144* C);
/*LUAT_ENTREE*/void r144avancer(T144* C);
/*LUAT_SOURCE*/void r142fabriquer_code(T142* C,T0* a1);
/*LUAT_SOURCE*/void r142fabriquer_commentaire(T142* C,T0* a1);
/*LUAT_SOURCE*/void r142afficher(T142* C,T0* a1);
/*BASIC_DIRECTORY*/void r93connect_to(T93* C,T0* a1);
/*BASIC_DIRECTORY*/void r93compute_absolute_file_path_with(T0* a1);
/*BASIC_DIRECTORY*/T6 r93respects_repertory_notation(T0* a1);
/*BASIC_DIRECTORY*/void r93set_notation_using(T0* a1);
extern T0*oBC93last_entry;
extern int fBC93last_entry;
/*BASIC_DIRECTORY*/T0* r93last_entry(void);
/*BASIC_DIRECTORY*/T0* r93current_working_directory(void);
/*BASIC_DIRECTORY*/void r93spell_as_repertory(T0* a1);
/*BASIC_DIRECTORY*/T0* r93system_notation(void);
/*BASIC_DIRECTORY*/void r93read_entry(T93* C);
extern T0*oBC93system_notation_buffer;
/*BASIC_DIRECTORY*/void r93disconnect(T93* C);
T172*create172fabriquer(void);
/*LUAT_ANALYSEUR_ADA*/void r172analyser(T172* C);
/*LUAT_ANALYSEUR_ADA*/void r172fabriquer(T172* C);
extern T0*oBC26traducteur;
extern int fBC26traducteur;
/*LUAT_ANALYSEUR_ADA*/T0* r172traducteur(void);
/*LUAT_ANALYSEUR_ADA*/void r172traiter_etat_initial(T172* C);
/*LUAT_ANALYSEUR_ADA*/T0* r172traduire(T0* a1);
/*LUAT_ANALYSEUR_ADA*/void r172produire_commentaire(T172* C);
/*LUAT_ANALYSEUR_ADA*/void r172appliquer(T172* C,T0* a1);
/*LUAT_ANALYSEUR_ADA*/void r172debrayer_fabrique(T172* C);
/*LUAT_ANALYSEUR_ADA*/void r172desactiver_code(T172* C);
/*LUAT_ANALYSEUR_ADA*/void r172embrayer_fabrique(T172* C);
/*LUAT_ANALYSEUR_ADA*/void r172produire_ligne(T172* C);
/*LUAT_ANALYSEUR_ADA*/void r172gerer_erreur(T172* C,T0* a1);
/*LUAT_ANALYSEUR_ADA*/void r172reinitialiser(T172* C);
/*LUAT_ANALYSEUR_ADA*/void r172activer_commentaire(T172* C);
/*LUAT_ANALYSEUR_ADA*/void r172desactiver_commentaire(T172* C);
/*LUAT_ANALYSEUR_ADA*/T6 r172est_utilise_fabrique(T172* C);
/*LUAT_ANALYSEUR_ADA*/void r172produire_code(T172* C);
/*LUAT_ANALYSEUR_ADA*/T0* r172lire(T172* C,T0* a1);
/*LUAT_ANALYSEUR_ADA*/void r172activer_code(T172* C);
/*LUAT_ANALYSEUR_ADA*/void r172_P_101_gerer_erreur(T172* C,T0* a1);
/*LUAT_ANALYSEUR_ADA*/void r172_P_101_produire_code(T172* C);
/*LUAT_ANALYSEUR_ADA*/void r172_P_101_fabriquer(T172* C);
T171*create171fabriquer(T0* a1);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171analyser(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171fabriquer(T171* C,T0* a1);
/*LUAT_ANALYSEUR_FAMILLE_C*/T0* r171traducteur(void);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171traiter_etat_initial(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/T0* r171traduire(T0* a1);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171fabriquer_analyseur(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171traiter_etat_lexeme_identifiant(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171traiter_commentaire_multiligne(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171traiter_etat_apres_apostrophe(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171traiter_etat_apres_guillemets(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171produire_commentaire(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171appliquer(T171* C,T0* a1);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171debrayer_fabrique(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171desactiver_code(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171embrayer_fabrique(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171produire_ligne(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171gerer_erreur(T171* C,T0* a1);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171reinitialiser(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171activer_commentaire(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171desactiver_commentaire(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/T6 r171est_utilise_fabrique(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171produire_code(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/T0* r171lire(T171* C,T0* a1);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171activer_code(T171* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r171_P_101_gerer_erreur(T171* C,T0* a1);
T170*create170fabriquer(void);
/*LUAT_ANALYSEUR_EIFFEL*/void r170analyser(T170* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r170fabriquer(T170* C);
/*LUAT_ANALYSEUR_EIFFEL*/T0* r170traducteur(void);
/*LUAT_ANALYSEUR_EIFFEL*/void r170traiter_etat_initial(T170* C);
/*LUAT_ANALYSEUR_EIFFEL*/T0* r170traduire(T0* a1);
/*LUAT_ANALYSEUR_EIFFEL*/void r170produire_commentaire(T170* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r170appliquer(T170* C,T0* a1);
/*LUAT_ANALYSEUR_EIFFEL*/void r170debrayer_fabrique(T170* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r170desactiver_code(T170* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r170embrayer_fabrique(T170* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r170produire_ligne(T170* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r170gerer_erreur(T170* C,T0* a1);
/*LUAT_ANALYSEUR_EIFFEL*/void r170reinitialiser(T170* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r170activer_commentaire(T170* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r170desactiver_commentaire(T170* C);
/*LUAT_ANALYSEUR_EIFFEL*/T6 r170est_utilise_fabrique(T170* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r170produire_code(T170* C);
/*LUAT_ANALYSEUR_EIFFEL*/T0* r170lire(T170* C,T0* a1);
/*LUAT_ANALYSEUR_EIFFEL*/void r170activer_code(T170* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r170_P_101_gerer_erreur(T170* C,T0* a1);
/*LUAT_ANALYSEUR_EIFFEL*/void r170_P_101_fabriquer(T170* C);
T169*create169(void);
/*LUAT_METRIQUE_EFFORT*/void r169mesurer(T169* C,T0* a1,T0* a2);
/*LUAT_METRIQUE_EFFORT*/T2 r169nb_ligne_partage(T0* a1,T0* a2);
/*LUAT_METRIQUE_EFFORT*/void r169copy(T169* C,T0* a1);
/*LUAT_METRIQUE_EFFORT*/T2 r169effort(T169* C);
/*LUAT_METRIQUE_EFFORT*/T0* r169twin(T169* C);
/*LUAT_METRIQUE_EFFORT*/void r169afficher(T169* C,T0* a1);
/*LUAT_METRIQUE_EFFORT*/void r169accumuler(T169* C,T0* a1);
T168*create168(void);
/*LUAT_METRIQUE_NORMAL*/void r168mesurer(T168* C,T0* a1,T0* a2);
/*LUAT_METRIQUE_NORMAL*/T2 r168nb_ligne_partage(T0* a1,T0* a2);
/*LUAT_METRIQUE_NORMAL*/void r168copy(T168* C,T0* a1);
/*LUAT_METRIQUE_NORMAL*/T0* r168twin(T168* C);
/*LUAT_METRIQUE_NORMAL*/void r168afficher(T168* C,T0* a1);
/*LUAT_METRIQUE_NORMAL*/void r168accumuler(T168* C,T0* a1);
/*SYSTEM*/T0* r94get_environment_variable(T0* a1);
/*DANG_ANALYSEUR*/void r109fabriquer(T109* C);
/*DANG_ANALYSEUR*/void r109lire(T109* C,T0* a1);
/*DANG_ANALYSEUR*/T6 r109existe_association(T109* C,T0* a1,T0* a2);
/*DANG_ANALYSEUR*/void r109fermer(T109* C);
/*DANG_ANALYSEUR*/void r109ouvrir(T109* C,T0* a1);
/*DANG_ANALYSEUR*/void r109ajouter_association(T109* C,T0* a1,T0* a2);
T173*create173(void);
/*LUAT_ORDRE_SUFFIXE*/T6 r173est_verifie(T0* a1,T0* a2);
/*LUAT_ORDRE_SUFFIXE*/T2 r173trichotomie(T0* a1,T0* a2);
/*LUAT_SUFFIXE*/void r97fabriquer(T97* C,T0* a1,T0* a2);
/*STD_OUTPUT*/void r49filtered_flush(T49* C);
/*STD_OUTPUT*/void r49filtered_put_character(T49* C,T3 a1);
extern T0*oBC13std_output;
extern int fBC13std_output;
/*STD_OUTPUT*/T0* r49std_output(void);
/*STD_OUTPUT*/void r49make(T49* C);
/*STD_OUTPUT*/void r49se_atexit(void);
/*STD_OUTPUT*/void r49write_buffer(T49* C);
/*STD_OUTPUT*/void r49put_boolean(T49* C,T6 a1);
/*STD_OUTPUT*/void r49put_character(T49* C,T3 a1);
/*STD_OUTPUT*/void r49flush(T49* C);
/*STD_OUTPUT*/void r49put_string(T49* C,T0* a1);
/*STD_OUTPUT*/void r49put_integer(T49* C,T11 a1);
/*STD_OUTPUT*/T0* r49tmp_string(void);
/*STD_OUTPUT*/void r49put_spaces(T49* C,T2 a1);
/*STD_OUTPUT*/void r49put_new_line(T49* C);
/*LUAT_COMMANDE_ANALYSE*/void r112fabriquer(T112* C,T0* a1,T0* a2);
extern T0*oBC26configuration;
extern int fBC26configuration;
/*LUAT_COMMANDE_ANALYSE*/T0* r112configuration(void);
/*LUAT_COMMANDE_ANALYSE*/T0* r112traducteur(void);
/*LUAT_COMMANDE_ANALYSE*/void r112executer(T112* C);
/*LUAT_LOT_ARBRE*/void r120lister_fichier(T120* C,T0* a1);
/*LUAT_LOT_ARBRE*/void r120fabriquer(T120* C,T0* a1,T6 a2);
/*LUAT_LOT_ARBRE*/void r120lire(T120* C);
/*LUAT_LOT_ARBRE*/T0* r120traducteur(void);
/*LUAT_LOT_ARBRE*/void r120clore(T120* C);
/*LUAT_COMMANDE_DIFFERENTIEL*/T6 r119sont_equivalents(T0* a1,T0* a2);
/*LUAT_COMMANDE_DIFFERENTIEL*/T0* r119std_output(void);
/*LUAT_COMMANDE_DIFFERENTIEL*/void r119fabriquer(T119* C,T0* a1,T0* a2,T0* a3);
extern T0*oBC26bilan;
/*LUAT_COMMANDE_DIFFERENTIEL*/T0* r119configuration(void);
/*LUAT_COMMANDE_DIFFERENTIEL*/void r119executer(T119* C);
/*LUAT_COMMANDE_UNITAIRE*/T0* r118std_output(void);
/*LUAT_COMMANDE_UNITAIRE*/void r118fabriquer(T118* C,T0* a1,T0* a2);
/*LUAT_COMMANDE_UNITAIRE*/T0* r118configuration(void);
/*LUAT_COMMANDE_UNITAIRE*/void r118executer(T118* C);
/*LUAT_LOT_LISTE*/void r117fabriquer(T117* C,T0* a1);
/*LUAT_LOT_LISTE*/void r117lire(T117* C);
/*LUAT_LOT_LISTE*/void r117clore(T117* C);
/*LUAT_LOT_LISTE*/T6 r117est_epuise(T117* C);
/*LUAT_LOT_LISTE*/T0* r117entree_courte(T117* C);
/*TEXT_FILE_READ*/void r74read_line_in(T74* C,T0* a1);
/*TEXT_FILE_READ*/void r74connect_to(T74* C,T0* a1);
/*TEXT_FILE_READ*/void r74read_available_in(T74* C,T0* a1,T2 a2);
/*TEXT_FILE_READ*/void r74read_line(T74* C);
extern T0*oBC46last_string;
extern int fBC46last_string;
/*TEXT_FILE_READ*/T0* r74last_string(void);
/*TEXT_FILE_READ*/void r74filtered_read_line_in(T74* C,T0* a1);
/*TEXT_FILE_READ*/void r74filtered_read_available_in(T74* C,T0* a1,T2 a2);
/*TEXT_FILE_READ*/void r74filtered_read_character(T74* C);
/*TEXT_FILE_READ*/void r74disconnect(T74* C);
/*TEXT_FILE_READ*/void r74fill_buffer(T74* C);
/*DIRECTORY*/void r114init(T114* C,T2 a1);
/*DIRECTORY*/void r114make(T114* C);
/*DIRECTORY*/T2 r114upper(T114* C);
/*DIRECTORY*/void r114scan(T114* C,T0* a1);
T175*create175(void);
/*LUAT_COMMANDE_CONFIGURATION*/T0* r175configuration(void);
/*LUAT_COMMANDE_CONFIGURATION*/void r175executer(void);
T148*create148(void);
/*LUAT_METRIQUE_UNITAIRE*/void r148mesurer(T148* C,T0* a1);
/*LUAT_METRIQUE_UNITAIRE*/void r148copy(T148* C,T0* a1);
/*LUAT_METRIQUE_UNITAIRE*/T0* r148twin(T148* C);
/*LUAT_METRIQUE_UNITAIRE*/T0* r148configuration(void);
/*LUAT_METRIQUE_UNITAIRE*/void r148afficher(T148* C,T0* a1);
/*LUAT_METRIQUE_UNITAIRE*/void r148accumuler(T148* C,T0* a1);
/*LUAT_BILAN*/void r59forcer_metrique(T59* C,T0* a1);
/*LUAT_BILAN*/void r59afficher(T59* C,T0* a1);
/*LUAT_BILAN*/void r59accumuler(T59* C,T0* a1);
/*LUAT_FILTRE*/void r102copy(T102* C,T0* a1);
/*LUAT_FILTRE*/T0* r102twin(T102* C);
/*LUAT_FILTRE*/T6 r102choix_est_effectue(T102* C);
/*LUAT_FILTRE*/void r102met(T102* C,T6 a1,T6 a2,T6 a3);
/*LUAT_FILTRE*/void r102initialiser(T102* C);
/*LUAT_FILTRE*/T6 r102choix_est_unique(T102* C);
/*LUAT_CONFIGURATION*/T0* r57std_output(void);
/*LUAT_CONFIGURATION*/void r57fabriquer(T57* C);
/*LUAT_CONFIGURATION*/void r57ajouter(T57* C,T0* a1,T0* a2,T0* a3);
/*LUAT_CONFIGURATION*/void r57traiter_erreur(T0* a1);
/*LUAT_CONFIGURATION*/void r57imposer(T57* C,T0* a1,T0* a2,T0* a3);
/*LUAT_CONFIGURATION*/void r57retirer(T57* C,T0* a1,T0* a2,T0* a3);
/*LUAT_CONFIGURATION*/void r57appliquer_choix_fichier(T57* C);
extern T0*oBC57analyseur_eiffel;
extern int fBC57analyseur_eiffel;
/*LUAT_CONFIGURATION*/T0* r57analyseur_eiffel(void);
/*LUAT_CONFIGURATION*/void r57ajouter_filtre(T0* a1,T0* a2);
extern T0*oBC57analyseur_ada;
extern int fBC57analyseur_ada;
/*LUAT_CONFIGURATION*/T0* r57analyseur_ada(void);
extern T0*oBC57analyseurs;
extern int fBC57analyseurs;
/*LUAT_CONFIGURATION*/T0* r57analyseurs(void);
/*LUAT_CONFIGURATION*/T0* r57trouver_analyseur(T0* a1);
extern T0*oBC57analyseur_c;
extern int fBC57analyseur_c;
/*LUAT_CONFIGURATION*/T0* r57analyseur_c(void);
extern T0*oBC57analyseur_c_plus_plus;
extern int fBC57analyseur_c_plus_plus;
/*LUAT_CONFIGURATION*/T0* r57analyseur_c_plus_plus(void);
/*LUAT_CONFIGURATION*/T2 r57trouver_element_configurable(T0* a1,T0* a2);
extern T0*oBC57metriques;
extern int fBC57metriques;
/*LUAT_CONFIGURATION*/T0* r57metriques(void);
/*LUAT_CONFIGURATION*/void r57retirer_filtre(T0* a1,T0* a2);
/*LUAT_CONFIGURATION*/void r57imposer_filtre(T0* a1,T0* a2);
/*LUAT_CONFIGURATION*/T6 r57forcer_analyseur(T57* C,T0* a1);
/*LUAT_CONFIGURATION*/T0* r57traducteur(void);
/*LUAT_CONFIGURATION*/T6 r57forcer_metrique(T57* C,T0* a1);
/*LUAT_CONFIGURATION*/T0* r57trouver_metrique(T0* a1);
extern T0*oBC57nom_fichier_configuration;
extern int fBC57nom_fichier_configuration;
/*LUAT_CONFIGURATION*/T0* r57nom_fichier_configuration(void);
/*LUAT_CONFIGURATION*/void r57afficher(T57* C);
/*LUAT_CONFIGURATION*/void r57appliquer_choix_initial(T57* C);
/*LUAT_CONFIGURATION*/T0* r57analyseur(T57* C,T0* a1);
/*LUAT_CONFIGURATION*/void r57afficher_filtre(T0* a1,T0* a2);
extern T0*oBC57metrique_normal;
extern int fBC57metrique_normal;
/*LUAT_CONFIGURATION*/T0* r57metrique_normal(void);
T174*create174(void);
/*LUAT_COMMANDE_BILAN*/T0* r174std_output(void);
/*LUAT_COMMANDE_BILAN*/void r174executer(void);
/*LUAT_TRADUCTEUR*/void r51init_in_default_directory(T51* C);
/*LUAT_TRADUCTEUR*/void r51set_text_domain(void);
/*LUAT_TRADUCTEUR*/void r51bind_text_domain(T0* a1,T0* a2);
/*LUAT_TRADUCTEUR*/void r51fabriquer(T51* C);
/*LUAT_TRADUCTEUR*/T0* r51traduire(T0* a1);
/*LUAT_TRADUCTEUR*/void r51register_domain(T51* C,T0* a1);
/*LUAT_TRADUCTEUR*/void r51set_default_message_locale(void);
/*LUAT_TRADUCTEUR*/void r51_P_53_init(T51* C);
/*STD_ERROR*/void r39filtered_flush(void);
/*STD_ERROR*/T0* r39std_output(void);
/*STD_ERROR*/void r39put_string(T0* a1);
/*STD_ERROR*/void r39put_spaces(T2 a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r67produire_commande_analyse(T67* C,T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r67fabriquer(T67* C);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T0* r67configuration(void);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T0* r67traducteur(void);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T2 r67argument_count(void);
extern T0*oBC27command_arguments;
extern int fBC27command_arguments;
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T0* r67command_arguments(void);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r67produire_arbre_commande_differentiel(T67* C,T0* a1,T0* a2);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r67produire_liste_commande_unitaire(T67* C,T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T0* r67ouvrir_arbre(T0* a1,T6 a2);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r67produire_commande_differentiel(T67* C,T0* a1,T0* a2);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r67produire_lot_commande_unitaire(T67* C,T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r67produire_lot_commande_differentiel(T67* C,T0* a1,T0* a2);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r67usage(void);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r67produire_commande_unitaire(T67* C,T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r67produire_liste_commande_analyse(T67* C,T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T0* r67ouvrir_liste(T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T2 r67comparer(T0* a1,T0* a2);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r67produire_arbre_commande_unitaire(T67* C,T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T6 r67est_repertoire(T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r67afficher_erreur(T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r67produire_lot_commande_analyse(T67* C,T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r67produire_arbre_commande_analyse(T67* C,T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r67analyser(T67* C);
typedef struct _se_agenT25C25l46c33 se_agenT25C25l46c33;
struct _se_agenT25C25l46c33{Tid id;
int creation_mold_id;
void(*afp)(se_agenT25C25l46c33*,T0*);
void(*gc_mark_agent_mold)(se_agenT25C25l46c33*);
int (*eq)(se_agent*,se_agent*);
};
typedef struct _se_agent_eq_r111executer se_agent_eq_r111executer;
struct _se_agent_eq_r111executer{Tid id;
int creation_mold_id;
void*afp;
void*gc_mark_agent_mold;
void*eq;
};
/*agent creation*/T0*agenT25C25l46c33(void);
void gc_mark_agenT25C25l46c33(se_agenT25C25l46c33*u);
/*agent equality*/int eq_agent_eq_r111executer(se_agent*u1, se_agent*u2);
/*LUAT_CODEMETRE*/T0* r25traducteur(void);
/*LUAT_CODEMETRE*/void r25principal(void);
/*LUAT_CODEMETRE*/void r25afficher_mention_legale(void);
void agent_launcher_LUAT_COMMANDE(/*agent*/T0*a,T0* a1);
union _se_agent{T0 s0;se_agent0 u0;
se_agenT25C25l46c33 uagenT25C25l46c33;
};
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#define SE_AGENTS 1
#define EIF_AGENT se_agent*

se_agent* new_agent(Tid id);

#ifdef SE_GC_LIB

  typedef struct B_agent gc_agent;

  struct B_agent {
    se_agent object;
    union {
      void *flag;
      gc_agent *next;
    } header;
  };

  extern gc_agent *store_agent;
  extern gc_agent *gc_free_agent;
  extern int       store_left_agent;
  extern fsoc     *store_chunk_agent;
  extern fsoc      H_agent;
  extern int       gc_info_nb_agent;

  void gc_align_mark_agent(fsoc *c, gc_agent* a);
  void gc_sweep_agent(fsoc *c);

#endif
extern T0*ms109_438530588bc109c36;
extern T0*ms57_2022577931;
extern T0*ms67_473806001;
extern T0*ms25_866438147;
extern T0*ms57_367646412bc57;
extern T0*ms57_78651488;
extern T0*ms6_59251;
extern T0*ms57_575269189bc57;
extern T0*ms118_200;
extern T0*ms57_1326235;
extern T0*ms118_237;
extern T0*ms57_1872750;
extern T0*ms170_238286578;
extern T0*ms143_190;
extern T0*ms170_1750975282;
extern T0*ms57_1636333591bc57;
extern T0*ms170_633654814;
extern T0*ms170_1882109223;
extern T0*ms172_953440447;
extern T0*ms67_955293794;
extern T0*ms120_276bc182;
extern T0*ms120_276bc187;
extern T0*ms170_1632850237bc170c22;
extern T0*ms170_1632850237bc170c21;
extern T0*ms112_139149946;
extern T0*ms6_14036bc7;
extern T0*ms57_917949021bc57c22;
extern T0*ms118_200bc57;
extern T0*ms109_438530588;
extern T0*ms170_896478796bc172;
extern T0*ms170_896478796bc171;
extern T0*ms170_896478796bc170;
extern T0*ms57_616531973bc57;
extern T0*ms170_1187496964bc170;
extern T0*ms57_1914603628;
extern T0*ms26_2030278;
extern T0*ms57_155679758bc57c21;
extern T0*ms57_78651488bc57;
extern T0*ms170_1632850237bc170c22l411;
extern T0*ms57_367646412;
extern T0*ms57_917949021bc57;
extern T0*ms57_2067555065bc57;
extern T0*ms119_497;
extern T0*ms57_616531973bc57c22;
extern T0*ms170_249419393bc171c19;
extern T0*ms67_659784771;
extern T0*ms170_896478796;
extern T0*ms170_1882109223bc171;
extern T0*ms170_1882109223bc172;
extern T0*ms170_2038230808;
extern T0*ms170_1835982646;
extern T0*ms57_89868;
extern T0*ms171_198117854;
extern T0*ms67_678062;
extern T0*ms172_998148855;
extern T0*ms67_212549485;
extern T0*ms170_1632850237bc170c21l430;
extern T0*ms57_1148145250;
extern T0*ms67_105509483;
extern T0*ms57_917949021;
extern T0*ms169_1977962;
extern T0*ms57_2067555065;
extern T0*ms25_1787719185;
extern T0*ms67_1206126564;
extern T0*ms143_21314053;
extern T0*ms67_356856294;
extern T0*ms172_128695907;
extern T0*ms57_1022;
extern T0*ms57_207;
extern T0*ms57_99;
extern T0*ms57_252;
extern T0*ms57_331;
extern T0*ms57_329;
extern T0*ms57_334;
extern T0*ms57_778583985;
extern T0*ms57_297;
extern T0*ms67_1511357824bc67;
extern T0*ms57_1347;
extern T0*ms67_1055124467bc67;
extern T0*ms57_1744;
extern T0*ms109_402183751;
extern T0*ms57_1774;
extern T0*ms57_72793912;
extern T0*ms183_1182938696;
extern T0*ms57_778583985bc57c21;
extern T0*ms57_1945510587;
extern T0*ms57_11429;
extern T0*ms57_1581702901bc57;
extern T0*ms57_2733;
extern T0*ms170_302894533;
extern T0*ms171_1760805737;
extern T0*ms57_1945510587bc57;
extern T0*ms57_338767662;
extern T0*ms57_2068456806;
extern T0*ms172_3022;
extern T0*ms67_1489194569;
extern T0*ms67_1055124467;
extern T0*ms67_177674639;
extern T0*ms172_10797639;
extern T0*ms112_482012695bc101;
extern T0*ms112_482012695;
extern T0*ms148_78787;
extern T0*ms67_184721825;
extern T0*ms57_5787;
extern T0*ms67_45085;
extern T0*ms57_252bc57;
extern T0*ms171_39279407;
extern T0*ms148_449372;
extern T0*ms67_1511357824;
extern T0*ms170_1632850237bc170;
extern T0*ms26_0;
extern T0*ms170_896478796bc171c19;
extern T0*ms57_15751;
extern T0*ms67_494198994;
extern T0*ms67_558072449;
extern T0*ms57_1978691;
extern T0*ms170_896478796bc172c21;
extern T0*ms170_249419393bc172;
extern T0*ms170_249419393bc171;
extern T0*ms57_9022;
extern T0*ms172_727364563bc172;
extern T0*ms57_27714646bc57c22;
extern T0*ms57_8773;
extern T0*ms57_8790;
extern T0*ms57_8897;
extern T0*ms170_302894533bc172;
extern T0*ms57_778583985bc57;
extern T0*ms67_1679497459;
extern T0*ms170_156993542;
extern T0*ms6_59251bc7;
extern T0*ms57_70779537;
extern T0*ms57_325069450;
extern T0*ms109_1655531153;
extern T0*ms170_1187496964;
extern T0*ms57_1402518293;
extern T0*ms170_1283315574;
extern T0*ms6_14036;
extern T0*ms67_1823520895;
extern T0*ms172_619685758;
extern T0*ms170_397163;
extern T0*ms57_325069450bc57;
extern T0*ms170_2117014773bc170;
extern T0*ms57_27714646bc57;
extern T0*ms170_613991936;
extern T0*ms67_482439428;
extern T0*ms67_1209197973bc57;
extern T0*ms119_1871339;
extern T0*ms170_2094708289bc170;
extern T0*ms57_1015274632bc57;
extern T0*ms67_667384374bc67;
extern T0*ms57_1402518293bc57;
extern T0*ms67_709525889;
extern T0*ms57_1387148262;
extern T0*ms168_357;
extern T0*ms168_422;
extern T0*ms168_367;
extern T0*ms171_2137071568;
extern T0*ms120_46bc187;
extern T0*ms57_105374505;
extern T0*ms57_1130825850;
extern T0*ms172_935023928;
extern T0*ms57_1308013269;
extern T0*ms57_1815775;
extern T0*ms120_1839491374;
extern T0*ms171_276953473;
extern T0*ms170_1283315574bc170;
extern T0*ms67_45085bc67;
extern T0*ms119_1159;
extern T0*ms119_1159bc119;
extern T0*ms119_363254;
extern T0*ms67_454460494;
extern T0*ms59_127398187;
extern T0*ms168_430693;
extern T0*ms170_249419393;
extern T0*ms6_14036bc7c15;
extern T0*ms170_1077131282bc170;
extern T0*ms112_482012695bc101c38;
extern T0*ms67_1196995941;
extern T0*ms26_0bc170;
extern T0*ms26_0bc171;
extern T0*ms26_0bc172;
extern T0*ms67_1689211819;
extern T0*ms101_250303104;
extern T0*ms170_1632850237;
extern T0*ms51_49306196;
extern T0*ms57_105374505bc57;
extern T0*ms67_1489194569bc57;
extern T0*ms109_1933550935;
extern T0*ms57_155679758;
extern T0*ms25_1860139408;
extern T0*ms120_276;
extern T0*ms101_1469960689;
extern T0*ms169_395586;
extern T0*ms112_689122201;
extern T0*ms67_667384374;
extern T0*ms26_0bc52;
extern T0*ms26_0bc93;
extern T0*ms67_1293198338bc67;
extern T0*ms170_2094708289;
extern T0*ms170_2117014773;
extern T0*ms142_134522190;
extern T0*ms171_155715434;
extern T0*ms67_322;
extern T0*ms57_20654818;
extern T0*ms101_83912;
extern T0*ms67_1511357824bc67c25;
extern T0*ms26_0bc52c9;
extern T0*ms171_510417238;
extern T0*ms171_1760805737bc171;
extern T0*ms170_1283315574bc170c22;
extern T0*ms119_45440454;
extern T0*ms67_404817563;
extern T0*ms57_1015274632;
extern T0*ms57_1945510587bc57c23;
extern T0*ms57_252bc57c31;
extern T0*ms67_1426;
extern T0*ms67_174479840;
extern T0*ms170_2094708289bc170c21;
extern T0*ms67_1293198338;
extern T0*ms118_200bc119;
extern T0*ms67_402629279;
extern T0*ms171_2126858037;
extern T0*ms171_509162564;
extern T0*ms109_402183751bc109c36;
extern T0*ms57_1636333591;
extern T0*ms109_402183751bc109;
extern T0*ms109_402183751bc170;
extern T0*ms67_1723129677;
extern T0*ms172_1916976;
extern T0*ms57_1581702901;
extern T0*ms67_1209197973;
extern T0*ms148_9893487;
extern T0*ms172_727364563;
extern T0*ms67_452763;
extern T0*ms57_27714646;
extern T0*ms120_7613394;
extern T0*ms67_820749808;
extern T0*ms67_16967612;
extern T0*ms109_1519585192;
extern T0*ms57_616531973;
extern T0*ms109_881684455;
extern T0*ms171_806032802;
extern T0*ms67_363423546;
extern T0*ms57_155679758bc57;
extern T0*ms57_1581702901bc57c22;
extern T0*ms120_46;
extern T0*ms170_1077131282;
extern T0*ms109_402183751bc109c36l170;
extern T0*ms142_166353;
extern T0*ms182_282;
extern T0*ms172_1594537947;
extern T0*ms109_438530588bc109;
extern T0*ms172_141014885;
extern T0*ms57_575269189;
extern T0*ms67_1652658481;
extern T0*ms101_1122;
extern T0*ms118_237bc119;
T0*se_ms(int c,char*e);
T0*se_string(char*e);
void se_msi1(void);
void se_msi2(void);
void se_msi3(void);
void se_msi4(void);
void se_msi5(void);
void se_msi6(void);
void manifest_string_mark1(void);
void once_function_mark(void);
void gc_start(void);
extern na_env na_env238;
typedef struct B237 gc237;
struct B237{T237 object;union {void*flag;gc237*next;} header;};
extern gc237*store237;
extern int store_left237;
extern fsoc*store_chunk237;
extern gc237*gc_free237;
typedef struct B236 gc236;
struct B236{T236 object;union {void*flag;gc236*next;} header;};
extern gc236*store236;
extern int store_left236;
extern fsoc*store_chunk236;
extern gc236*gc_free236;
extern na_env na_env235;
typedef struct B73 gc73;
struct B73{T73 object;union {void*flag;gc73*next;} header;};
extern gc73*store73;
extern int store_left73;
extern fsoc*store_chunk73;
extern gc73*gc_free73;
typedef struct B234 gc234;
struct B234{T234 object;union {void*flag;gc234*next;} header;};
extern gc234*store234;
extern int store_left234;
extern fsoc*store_chunk234;
extern gc234*gc_free234;
extern na_env na_env232;
typedef struct B230 gc230;
struct B230{T230 object;union {void*flag;gc230*next;} header;};
extern gc230*store230;
extern int store_left230;
extern fsoc*store_chunk230;
extern gc230*gc_free230;
typedef struct B187 gc187;
struct B187{T187 object;union {void*flag;gc187*next;} header;};
extern gc187*store187;
extern int store_left187;
extern fsoc*store_chunk187;
extern gc187*gc_free187;
typedef struct B182 gc182;
struct B182{T182 object;union {void*flag;gc182*next;} header;};
extern gc182*store182;
extern int store_left182;
extern fsoc*store_chunk182;
extern gc182*gc_free182;
typedef struct B146 gc146;
struct B146{T146 object;union {void*flag;gc146*next;} header;};
extern gc146*store146;
extern int store_left146;
extern fsoc*store_chunk146;
extern gc146*gc_free146;
typedef struct B143 gc143;
struct B143{T143 object;union {void*flag;gc143*next;} header;};
extern gc143*store143;
extern int store_left143;
extern fsoc*store_chunk143;
extern gc143*gc_free143;
extern na_env na_env228;
extern na_env na_env227;
typedef struct B226 gc226;
struct B226{T226 object;union {void*flag;gc226*next;} header;};
extern gc226*store226;
extern int store_left226;
extern fsoc*store_chunk226;
extern gc226*gc_free226;
typedef struct B225 gc225;
struct B225{T225 object;union {void*flag;gc225*next;} header;};
extern gc225*store225;
extern int store_left225;
extern fsoc*store_chunk225;
extern gc225*gc_free225;
typedef struct B224 gc224;
struct B224{T224 object;union {void*flag;gc224*next;} header;};
extern gc224*store224;
extern int store_left224;
extern fsoc*store_chunk224;
extern gc224*gc_free224;
typedef struct B223 gc223;
struct B223{T223 object;union {void*flag;gc223*next;} header;};
extern gc223*store223;
extern int store_left223;
extern fsoc*store_chunk223;
extern gc223*gc_free223;
typedef struct B222 gc222;
struct B222{T222 object;union {void*flag;gc222*next;} header;};
extern gc222*store222;
extern int store_left222;
extern fsoc*store_chunk222;
extern gc222*gc_free222;
typedef struct B221 gc221;
struct B221{T221 object;union {void*flag;gc221*next;} header;};
extern gc221*store221;
extern int store_left221;
extern fsoc*store_chunk221;
extern gc221*gc_free221;
typedef struct B191 gc191;
struct B191{T191 object;union {void*flag;gc191*next;} header;};
extern gc191*store191;
extern int store_left191;
extern fsoc*store_chunk191;
extern gc191*gc_free191;
typedef struct B141 gc141;
struct B141{T141 object;union {void*flag;gc141*next;} header;};
extern gc141*store141;
extern int store_left141;
extern fsoc*store_chunk141;
extern gc141*gc_free141;
typedef struct B219 gc219;
struct B219{T219 object;union {void*flag;gc219*next;} header;};
extern gc219*store219;
extern int store_left219;
extern fsoc*store_chunk219;
extern gc219*gc_free219;
typedef struct B190 gc190;
struct B190{T190 object;union {void*flag;gc190*next;} header;};
extern gc190*store190;
extern int store_left190;
extern fsoc*store_chunk190;
extern gc190*gc_free190;
typedef struct B217 gc217;
struct B217{T217 object;union {void*flag;gc217*next;} header;};
extern gc217*store217;
extern int store_left217;
extern fsoc*store_chunk217;
extern gc217*gc_free217;
extern na_env na_env216;
extern na_env na_env215;
typedef struct B157 gc157;
struct B157{T157 object;union {void*flag;gc157*next;} header;};
extern gc157*store157;
extern int store_left157;
extern fsoc*store_chunk157;
extern gc157*gc_free157;
extern na_env na_env214;
typedef struct B177 gc177;
struct B177{T177 object;union {void*flag;gc177*next;} header;};
extern gc177*store177;
extern int store_left177;
extern fsoc*store_chunk177;
extern gc177*gc_free177;
typedef struct B188 gc188;
struct B188{T188 object;union {void*flag;gc188*next;} header;};
extern gc188*store188;
extern int store_left188;
extern fsoc*store_chunk188;
extern gc188*gc_free188;
typedef struct B186 gc186;
struct B186{T186 object;union {void*flag;gc186*next;} header;};
extern gc186*store186;
extern int store_left186;
extern fsoc*store_chunk186;
extern gc186*gc_free186;
typedef struct B185 gc185;
struct B185{T185 object;union {void*flag;gc185*next;} header;};
extern gc185*store185;
extern int store_left185;
extern fsoc*store_chunk185;
extern gc185*gc_free185;
typedef struct B178 gc178;
struct B178{T178 object;union {void*flag;gc178*next;} header;};
extern gc178*store178;
extern int store_left178;
extern fsoc*store_chunk178;
extern gc178*gc_free178;
typedef struct B184 gc184;
struct B184{T184 object;union {void*flag;gc184*next;} header;};
extern gc184*store184;
extern int store_left184;
extern fsoc*store_chunk184;
extern gc184*gc_free184;
typedef struct B213 gc213;
struct B213{T213 object;union {void*flag;gc213*next;} header;};
extern gc213*store213;
extern int store_left213;
extern fsoc*store_chunk213;
extern gc213*gc_free213;
typedef struct B145 gc145;
struct B145{T145 object;union {void*flag;gc145*next;} header;};
extern gc145*store145;
extern int store_left145;
extern fsoc*store_chunk145;
extern gc145*gc_free145;
typedef struct B144 gc144;
struct B144{T144 object;union {void*flag;gc144*next;} header;};
extern gc144*store144;
extern int store_left144;
extern fsoc*store_chunk144;
extern gc144*gc_free144;
typedef struct B142 gc142;
struct B142{T142 object;union {void*flag;gc142*next;} header;};
extern gc142*store142;
extern int store_left142;
extern fsoc*store_chunk142;
extern gc142*gc_free142;
typedef struct B212 gc212;
struct B212{T212 object;union {void*flag;gc212*next;} header;};
extern gc212*store212;
extern int store_left212;
extern fsoc*store_chunk212;
extern gc212*gc_free212;
extern na_env na_env211;
extern na_env na_env210;
typedef struct B209 gc209;
struct B209{T209 object;union {void*flag;gc209*next;} header;};
extern gc209*store209;
extern int store_left209;
extern fsoc*store_chunk209;
extern gc209*gc_free209;
typedef struct B208 gc208;
struct B208{T208 object;union {void*flag;gc208*next;} header;};
extern gc208*store208;
extern int store_left208;
extern fsoc*store_chunk208;
extern gc208*gc_free208;
typedef struct B207 gc207;
struct B207{T207 object;union {void*flag;gc207*next;} header;};
extern gc207*store207;
extern int store_left207;
extern fsoc*store_chunk207;
extern gc207*gc_free207;
typedef struct B206 gc206;
struct B206{T206 object;union {void*flag;gc206*next;} header;};
extern gc206*store206;
extern int store_left206;
extern fsoc*store_chunk206;
extern gc206*gc_free206;
extern na_env na_env205;
typedef struct B172 gc172;
struct B172{T172 object;union {void*flag;gc172*next;} header;};
extern gc172*store172;
extern int store_left172;
extern fsoc*store_chunk172;
extern gc172*gc_free172;
typedef struct B171 gc171;
struct B171{T171 object;union {void*flag;gc171*next;} header;};
extern gc171*store171;
extern int store_left171;
extern fsoc*store_chunk171;
extern gc171*gc_free171;
typedef struct B170 gc170;
struct B170{T170 object;union {void*flag;gc170*next;} header;};
extern gc170*store170;
extern int store_left170;
extern fsoc*store_chunk170;
extern gc170*gc_free170;
typedef struct B202 gc202;
struct B202{T202 object;union {void*flag;gc202*next;} header;};
extern gc202*store202;
extern int store_left202;
extern fsoc*store_chunk202;
extern gc202*gc_free202;
typedef struct B169 gc169;
struct B169{T169 object;union {void*flag;gc169*next;} header;};
extern gc169*store169;
extern int store_left169;
extern fsoc*store_chunk169;
extern gc169*gc_free169;
typedef struct B168 gc168;
struct B168{T168 object;union {void*flag;gc168*next;} header;};
extern gc168*store168;
extern int store_left168;
extern fsoc*store_chunk168;
extern gc168*gc_free168;
typedef struct B200 gc200;
struct B200{T200 object;union {void*flag;gc200*next;} header;};
extern gc200*store200;
extern int store_left200;
extern fsoc*store_chunk200;
extern gc200*gc_free200;
typedef struct B199 gc199;
struct B199{T199 object;union {void*flag;gc199*next;} header;};
extern gc199*store199;
extern int store_left199;
extern fsoc*store_chunk199;
extern gc199*gc_free199;
typedef struct B109 gc109;
struct B109{T109 object;union {void*flag;gc109*next;} header;};
extern gc109*store109;
extern int store_left109;
extern fsoc*store_chunk109;
extern gc109*gc_free109;
typedef struct B173 gc173;
struct B173{T173 object;union {void*flag;gc173*next;} header;};
extern gc173*store173;
extern int store_left173;
extern fsoc*store_chunk173;
extern gc173*gc_free173;
typedef struct B97 gc97;
struct B97{T97 object;union {void*flag;gc97*next;} header;};
extern gc97*store97;
extern int store_left97;
extern fsoc*store_chunk97;
extern gc97*gc_free97;
typedef struct B197 gc197;
struct B197{T197 object;union {void*flag;gc197*next;} header;};
extern gc197*store197;
extern int store_left197;
extern fsoc*store_chunk197;
extern gc197*gc_free197;
typedef struct B49 gc49;
struct B49{T49 object;union {void*flag;gc49*next;} header;};
extern gc49*store49;
extern int store_left49;
extern fsoc*store_chunk49;
extern gc49*gc_free49;
extern na_env na_env196;
typedef struct B112 gc112;
struct B112{T112 object;union {void*flag;gc112*next;} header;};
extern gc112*store112;
extern int store_left112;
extern fsoc*store_chunk112;
extern gc112*gc_free112;
typedef struct B195 gc195;
struct B195{T195 object;union {void*flag;gc195*next;} header;};
extern gc195*store195;
extern int store_left195;
extern fsoc*store_chunk195;
extern gc195*gc_free195;
typedef struct B120 gc120;
struct B120{T120 object;union {void*flag;gc120*next;} header;};
extern gc120*store120;
extern int store_left120;
extern fsoc*store_chunk120;
extern gc120*gc_free120;
typedef struct B119 gc119;
struct B119{T119 object;union {void*flag;gc119*next;} header;};
extern gc119*store119;
extern int store_left119;
extern fsoc*store_chunk119;
extern gc119*gc_free119;
typedef struct B118 gc118;
struct B118{T118 object;union {void*flag;gc118*next;} header;};
extern gc118*store118;
extern int store_left118;
extern fsoc*store_chunk118;
extern gc118*gc_free118;
typedef struct B117 gc117;
struct B117{T117 object;union {void*flag;gc117*next;} header;};
extern gc117*store117;
extern int store_left117;
extern fsoc*store_chunk117;
extern gc117*gc_free117;
typedef struct B74 gc74;
struct B74{T74 object;union {void*flag;gc74*next;} header;};
extern gc74*store74;
extern int store_left74;
extern fsoc*store_chunk74;
extern gc74*gc_free74;
typedef struct B116 gc116;
struct B116{T116 object;union {void*flag;gc116*next;} header;};
extern gc116*store116;
extern int store_left116;
extern fsoc*store_chunk116;
extern gc116*gc_free116;
typedef struct B114 gc114;
struct B114{T114 object;union {void*flag;gc114*next;} header;};
extern gc114*store114;
extern int store_left114;
extern fsoc*store_chunk114;
extern gc114*gc_free114;
typedef struct B175 gc175;
struct B175{T175 object;union {void*flag;gc175*next;} header;};
extern gc175*store175;
extern int store_left175;
extern fsoc*store_chunk175;
extern gc175*gc_free175;
typedef struct B148 gc148;
struct B148{T148 object;union {void*flag;gc148*next;} header;};
extern gc148*store148;
extern int store_left148;
extern fsoc*store_chunk148;
extern gc148*gc_free148;
typedef struct B59 gc59;
struct B59{T59 object;union {void*flag;gc59*next;} header;};
extern gc59*store59;
extern int store_left59;
extern fsoc*store_chunk59;
extern gc59*gc_free59;
typedef struct B102 gc102;
struct B102{T102 object;union {void*flag;gc102*next;} header;};
extern gc102*store102;
extern int store_left102;
extern fsoc*store_chunk102;
extern gc102*gc_free102;
typedef struct B57 gc57;
struct B57{T57 object;union {void*flag;gc57*next;} header;};
extern gc57*store57;
extern int store_left57;
extern fsoc*store_chunk57;
extern gc57*gc_free57;
typedef struct B174 gc174;
struct B174{T174 object;union {void*flag;gc174*next;} header;};
extern gc174*store174;
extern int store_left174;
extern fsoc*store_chunk174;
extern gc174*gc_free174;
typedef struct B51 gc51;
struct B51{T51 object;union {void*flag;gc51*next;} header;};
extern gc51*store51;
extern int store_left51;
extern fsoc*store_chunk51;
extern gc51*gc_free51;
extern na_env na_env9;
typedef struct B7 gc7;
struct B7{T7 object;union {void*flag;gc7*next;} header;};
extern gc7*store7;
extern int store_left7;
extern fsoc*store_chunk7;
extern gc7*gc_free7;
typedef struct B39 gc39;
struct B39{T39 object;union {void*flag;gc39*next;} header;};
extern gc39*store39;
extern int store_left39;
extern fsoc*store_chunk39;
extern gc39*gc_free39;

#define gc_mark193(x) (((se_agent0*)(x))->gc_mark_agent_mold((se_agent*)(x)))

typedef struct B192 gc192;
struct B192{T192 object;union {void*flag;gc192*next;} header;};
extern gc192*store192;
extern int store_left192;
extern fsoc*store_chunk192;
extern gc192*gc_free192;
typedef struct B67 gc67;
struct B67{T67 object;union {void*flag;gc67*next;} header;};
extern gc67*store67;
extern int store_left67;
extern fsoc*store_chunk67;
extern gc67*gc_free67;
typedef struct B25 gc25;
struct B25{T25 object;union {void*flag;gc25*next;} header;};
extern gc25*store25;
extern int store_left25;
extern fsoc*store_chunk25;
extern gc25*gc_free25;
void gc_mark238(T238 o);
T238 new238(unsigned int size);
void gc_sweep237(fsoc*c);
void gc_mark237(T237*o);
void gc_align_mark237(fsoc*c,gc237*p);
extern fsoc H237;
T237*new237(void);
void gc_sweep236(fsoc*c);
void gc_mark236(T236*o);
void gc_align_mark236(fsoc*c,gc236*p);
extern fsoc H236;
T236*new236(void);
void gc_mark235(T235 o);
T235 new235(unsigned int size);
void gc_sweep73(fsoc*c);
void gc_mark73(T73*o);
void gc_align_mark73(fsoc*c,gc73*p);
extern fsoc H73;
T73*new73(void);
void gc_sweep234(fsoc*c);
void gc_mark234(T234*o);
void gc_align_mark234(fsoc*c,gc234*p);
extern fsoc H234;
T234*new234(void);
void gc_mark232(T232 o);
T232 new232(unsigned int size);
void gc_sweep230(fsoc*c);
void gc_mark230(T230*o);
void gc_align_mark230(fsoc*c,gc230*p);
extern fsoc H230;
T230*new230(void);
void gc_sweep187(fsoc*c);
void gc_mark187(T187*o);
void gc_align_mark187(fsoc*c,gc187*p);
extern fsoc H187;
T187*new187(void);
void gc_sweep182(fsoc*c);
void gc_mark182(T182*o);
void gc_align_mark182(fsoc*c,gc182*p);
extern fsoc H182;
T182*new182(void);
void gc_sweep146(fsoc*c);
void gc_mark146(T146*o);
void gc_align_mark146(fsoc*c,gc146*p);
extern fsoc H146;
T146*new146(void);
void gc_sweep143(fsoc*c);
void gc_mark143(T143*o);
void gc_align_mark143(fsoc*c,gc143*p);
extern fsoc H143;
T143*new143(void);
void gc_mark228(T228 o);
T228 new228(unsigned int size);
void gc_mark227(T227 o);
T227 new227(unsigned int size);
void gc_sweep226(fsoc*c);
void gc_mark226(T226*o);
void gc_align_mark226(fsoc*c,gc226*p);
extern fsoc H226;
T226*new226(void);
void gc_sweep225(fsoc*c);
void gc_mark225(T225*o);
void gc_align_mark225(fsoc*c,gc225*p);
extern fsoc H225;
T225*new225(void);
void gc_sweep224(fsoc*c);
void gc_mark224(T224*o);
void gc_align_mark224(fsoc*c,gc224*p);
extern fsoc H224;
T224*new224(void);
void gc_sweep223(fsoc*c);
void gc_mark223(T223*o);
void gc_align_mark223(fsoc*c,gc223*p);
extern fsoc H223;
T223*new223(void);
void gc_sweep222(fsoc*c);
void gc_mark222(T222*o);
void gc_align_mark222(fsoc*c,gc222*p);
extern fsoc H222;
T222*new222(void);
void gc_sweep221(fsoc*c);
void gc_mark221(T221*o);
void gc_align_mark221(fsoc*c,gc221*p);
extern fsoc H221;
T221*new221(void);
void gc_sweep191(fsoc*c);
void gc_mark191(T191*o);
void gc_align_mark191(fsoc*c,gc191*p);
extern fsoc H191;
T191*new191(void);
void gc_sweep141(fsoc*c);
void gc_mark141(T141*o);
void gc_align_mark141(fsoc*c,gc141*p);
extern fsoc H141;
T141*new141(void);
void gc_sweep219(fsoc*c);
void gc_mark219(T219*o);
void gc_align_mark219(fsoc*c,gc219*p);
extern fsoc H219;
T219*new219(void);
void gc_sweep190(fsoc*c);
void gc_mark190(T190*o);
void gc_align_mark190(fsoc*c,gc190*p);
extern fsoc H190;
T190*new190(void);
void gc_sweep217(fsoc*c);
void gc_mark217(T217*o);
void gc_align_mark217(fsoc*c,gc217*p);
extern fsoc H217;
T217*new217(void);
void gc_mark216(T216 o);
T216 new216(unsigned int size);
void gc_mark215(T215 o);
T215 new215(unsigned int size);
void gc_sweep157(fsoc*c);
void gc_mark157(T157*o);
void gc_align_mark157(fsoc*c,gc157*p);
extern fsoc H157;
T157*new157(void);
void gc_mark214(T214 o);
T214 new214(unsigned int size);
void gc_sweep177(fsoc*c);
void gc_mark177(T177*o);
void gc_align_mark177(fsoc*c,gc177*p);
extern fsoc H177;
T177*new177(void);
void gc_sweep188(fsoc*c);
void gc_mark188(T188*o);
void gc_align_mark188(fsoc*c,gc188*p);
extern fsoc H188;
T188*new188(void);
void gc_sweep186(fsoc*c);
void gc_mark186(T186*o);
void gc_align_mark186(fsoc*c,gc186*p);
extern fsoc H186;
T186*new186(void);
void gc_sweep185(fsoc*c);
void gc_mark185(T185*o);
void gc_align_mark185(fsoc*c,gc185*p);
extern fsoc H185;
T185*new185(void);
void gc_sweep178(fsoc*c);
void gc_mark178(T178*o);
void gc_align_mark178(fsoc*c,gc178*p);
extern fsoc H178;
T178*new178(void);
void gc_sweep184(fsoc*c);
void gc_mark184(T184*o);
void gc_align_mark184(fsoc*c,gc184*p);
extern fsoc H184;
T184*new184(void);
void gc_sweep213(fsoc*c);
void gc_mark213(T213*o);
void gc_align_mark213(fsoc*c,gc213*p);
extern fsoc H213;
T213*new213(void);
void gc_sweep145(fsoc*c);
void gc_mark145(T145*o);
void gc_align_mark145(fsoc*c,gc145*p);
extern fsoc H145;
T145*new145(void);
void gc_sweep144(fsoc*c);
void gc_mark144(T144*o);
void gc_align_mark144(fsoc*c,gc144*p);
extern fsoc H144;
T144*new144(void);
void gc_sweep142(fsoc*c);
void gc_mark142(T142*o);
void gc_align_mark142(fsoc*c,gc142*p);
extern fsoc H142;
T142*new142(void);
void gc_sweep212(fsoc*c);
void gc_mark212(T212*o);
void gc_align_mark212(fsoc*c,gc212*p);
extern fsoc H212;
T212*new212(void);
void gc_mark211(T211 o);
T211 new211(unsigned int size);
void gc_mark210(T210 o);
T210 new210(unsigned int size);
void gc_sweep209(fsoc*c);
void gc_mark209(T209*o);
void gc_align_mark209(fsoc*c,gc209*p);
extern fsoc H209;
T209*new209(void);
void gc_sweep208(fsoc*c);
void gc_mark208(T208*o);
void gc_align_mark208(fsoc*c,gc208*p);
extern fsoc H208;
T208*new208(void);
void gc_sweep207(fsoc*c);
void gc_mark207(T207*o);
void gc_align_mark207(fsoc*c,gc207*p);
extern fsoc H207;
T207*new207(void);
void gc_sweep206(fsoc*c);
void gc_mark206(T206*o);
void gc_align_mark206(fsoc*c,gc206*p);
extern fsoc H206;
T206*new206(void);
void gc_mark205(T205 o);
T205 new205(unsigned int size);
void gc_sweep172(fsoc*c);
void gc_mark172(T172*o);
void gc_align_mark172(fsoc*c,gc172*p);
extern fsoc H172;
T172*new172(void);
void gc_sweep171(fsoc*c);
void gc_mark171(T171*o);
void gc_align_mark171(fsoc*c,gc171*p);
extern fsoc H171;
T171*new171(void);
void gc_sweep170(fsoc*c);
void gc_mark170(T170*o);
void gc_align_mark170(fsoc*c,gc170*p);
extern fsoc H170;
T170*new170(void);
void gc_sweep202(fsoc*c);
void gc_mark202(T202*o);
void gc_align_mark202(fsoc*c,gc202*p);
extern fsoc H202;
T202*new202(void);
void gc_sweep169(fsoc*c);
void gc_mark169(T169*o);
void gc_align_mark169(fsoc*c,gc169*p);
extern fsoc H169;
T169*new169(void);
void gc_sweep168(fsoc*c);
void gc_mark168(T168*o);
void gc_align_mark168(fsoc*c,gc168*p);
extern fsoc H168;
T168*new168(void);
void gc_sweep200(fsoc*c);
void gc_mark200(T200*o);
void gc_align_mark200(fsoc*c,gc200*p);
extern fsoc H200;
T200*new200(void);
void gc_sweep199(fsoc*c);
void gc_mark199(T199*o);
void gc_align_mark199(fsoc*c,gc199*p);
extern fsoc H199;
T199*new199(void);
void gc_sweep109(fsoc*c);
void gc_mark109(T109*o);
void gc_align_mark109(fsoc*c,gc109*p);
extern fsoc H109;
T109*new109(void);
void gc_sweep173(fsoc*c);
void gc_mark173(T173*o);
void gc_align_mark173(fsoc*c,gc173*p);
extern fsoc H173;
T173*new173(void);
void gc_sweep97(fsoc*c);
void gc_mark97(T97*o);
void gc_align_mark97(fsoc*c,gc97*p);
extern fsoc H97;
T97*new97(void);
void gc_sweep197(fsoc*c);
void gc_mark197(T197*o);
void gc_align_mark197(fsoc*c,gc197*p);
extern fsoc H197;
T197*new197(void);
void gc_sweep49(fsoc*c);
void gc_mark49(T49*o);
void gc_align_mark49(fsoc*c,gc49*p);
extern fsoc H49;
T49*new49(void);
void gc_mark196(T196 o);
T196 new196(unsigned int size);
void gc_sweep112(fsoc*c);
void gc_mark112(T112*o);
void gc_align_mark112(fsoc*c,gc112*p);
extern fsoc H112;
T112*new112(void);
void gc_sweep195(fsoc*c);
void gc_mark195(T195*o);
void gc_align_mark195(fsoc*c,gc195*p);
extern fsoc H195;
T195*new195(void);
void gc_sweep120(fsoc*c);
void gc_mark120(T120*o);
void gc_align_mark120(fsoc*c,gc120*p);
extern fsoc H120;
T120*new120(void);
void gc_sweep119(fsoc*c);
void gc_mark119(T119*o);
void gc_align_mark119(fsoc*c,gc119*p);
extern fsoc H119;
T119*new119(void);
void gc_sweep118(fsoc*c);
void gc_mark118(T118*o);
void gc_align_mark118(fsoc*c,gc118*p);
extern fsoc H118;
T118*new118(void);
void gc_sweep117(fsoc*c);
void gc_mark117(T117*o);
void gc_align_mark117(fsoc*c,gc117*p);
extern fsoc H117;
T117*new117(void);
void gc_sweep74(fsoc*c);
void gc_mark74(T74*o);
void gc_align_mark74(fsoc*c,gc74*p);
extern fsoc H74;
T74*new74(void);
void gc_sweep116(fsoc*c);
void gc_mark116(T116*o);
void gc_align_mark116(fsoc*c,gc116*p);
extern fsoc H116;
T116*new116(void);
void gc_sweep114(fsoc*c);
void gc_mark114(T114*o);
void gc_align_mark114(fsoc*c,gc114*p);
extern fsoc H114;
T114*new114(void);
void gc_sweep175(fsoc*c);
void gc_mark175(T175*o);
void gc_align_mark175(fsoc*c,gc175*p);
extern fsoc H175;
T175*new175(void);
void gc_sweep148(fsoc*c);
void gc_mark148(T148*o);
void gc_align_mark148(fsoc*c,gc148*p);
extern fsoc H148;
T148*new148(void);
void gc_sweep59(fsoc*c);
void gc_mark59(T59*o);
void gc_align_mark59(fsoc*c,gc59*p);
extern fsoc H59;
T59*new59(void);
void gc_sweep102(fsoc*c);
void gc_mark102(T102*o);
void gc_align_mark102(fsoc*c,gc102*p);
extern fsoc H102;
T102*new102(void);
void gc_sweep57(fsoc*c);
void gc_mark57(T57*o);
void gc_align_mark57(fsoc*c,gc57*p);
extern fsoc H57;
T57*new57(void);
void gc_sweep174(fsoc*c);
void gc_mark174(T174*o);
void gc_align_mark174(fsoc*c,gc174*p);
extern fsoc H174;
T174*new174(void);
void gc_sweep51(fsoc*c);
void gc_mark51(T51*o);
void gc_align_mark51(fsoc*c,gc51*p);
extern fsoc H51;
T51*new51(void);
void gc_mark9(T9 o);
T9 new9(unsigned int size);
void gc_sweep7(fsoc*c);
void gc_mark7(T7*o);
void gc_align_mark7(fsoc*c,gc7*p);
extern fsoc H7;
T7*new7(void);
void gc_sweep39(fsoc*c);
void gc_mark39(T39*o);
void gc_align_mark39(fsoc*c,gc39*p);
extern fsoc H39;
T39*new39(void);
void gc_sweep192(fsoc*c);
void gc_mark192(T192*o);
void gc_align_mark192(fsoc*c,gc192*p);
extern fsoc H192;
T192*new192(void);
void gc_sweep67(fsoc*c);
void gc_mark67(T67*o);
void gc_align_mark67(fsoc*c,gc67*p);
extern fsoc H67;
T67*new67(void);
void gc_sweep25(fsoc*c);
void gc_mark25(T25*o);
void gc_align_mark25(fsoc*c,gc25*p);
extern fsoc H25;
T25*new25(void);
void Xgc_mark99(T0*o);
void Xgc_mark136(T0*o);
void Xgc_mark111(T0*o);
void Xgc_mark98(T0*o);
void Xgc_mark101(T0*o);
extern T25*eiffel_root_object;
extern int se_argc;
extern char**se_argv;
#define SE_MAXID 239
extern T7*g[];
extern T7*t[];
extern int se_strucT[];
extern T0*oBC138rouge;
extern T0*oBC138noir;
void se_atexit(void);
void initialize_eiffel_runtime(int argc,char*argv[]);
int main(int argc,char*argv[]);
void X28put_character(T0*C,T3 a1);
void X28put_string(T0*C,T0* a1);
void X28put_integer(T0*C,T11 a1);
T0* X28tmp_string(T0*C);
void X28put_spaces(T0*C,T2 a1);
void X28filtered_put_character(T0*C,T3 a1);
void X28put_new_line(T0*C);
T6 X136respects_repertory_notation(T0*C,T0* a1);
void X136to_directory_path(T0*C,T0* a1);
void X136to_absolute_path_in(T0*C,T0* a1,T0* a2);
void X136to_subpath_with(T0*C,T0* a1,T0* a2);
void X136spell_as_repertory(T0*C,T0* a1);
T6 X136is_absolute_path(T0*C,T0* a1);
T0* X101fabrique(T0*C);
void X101appliquer(T0*C,T0* a1);
T0* X101message_erreur(T0*C);
void X101debrayer_fabrique(T0*C);
T6 X101code_pris_en_compte(T0*C);
void X101desactiver_code(T0*C);
void X101embrayer_fabrique(T0*C);
T0* X101langage(T0*C);
T0* X101traducteur(T0*C);
void X101reinitialiser(T0*C);
T6 X101commentaire_pris_en_compte(T0*C);
void X101activer_commentaire(T0*C);
void X101desactiver_commentaire(T0*C);
T0* X101fichier(T0*C);
T6 X101est_utilise_fabrique(T0*C);
T0* X101listage(T0*C);
T0* X101traduire(T0*C,T0* a1);
T0* X101lire(T0*C,T0* a1);
void X101activer_code(T0*C);
void X101analyser(T0*C);
T0* X100clef(T0*C);
void X181join_to(T0*C,T0* a1);
void X111executer(T0*C);
T0* X99twin(T0*C);
void X99copy(T0*C,T0* a1);
void X99afficher(T0*C,T0* a1);
void X99accumuler(T0*C,T0* a1);
T2 X201lower(T0*C);
T2 X201upper(T0*C);
T0* X201item(T0*C,T2 a1);
void X98mesurer(T0*C,T0* a1,T0* a2);
T0* X98nom(T0*C);
T0* X98twin(T0*C);
void X98copy(T0*C,T0* a1);
void X98afficher(T0*C,T0* a1);
T0* X113entree(T0*C);
void X113clore(T0*C);
T6 X113est_epuise(T0*C);
T0* X113entree_courte(T0*C);
void X113lire(T0*C);
void X180join_up(T0*C);
void X180start_join(T0*C,T0* a1,T2 a2);
void X180end_join(T0*C);
void X180join_element(T0*C,T0* a1);
void X180join_directory(T0*C,T0* a1);

#ifdef __cplusplus
}
#endif
