#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 2.3 (Thursday July 11th 2007) [Antoine-Auguste Parmentier]
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER F.MERIZEN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe -O3 -fomit-frame-pointer -funroll-loops -ffast-math
*/

/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.h) contains all basic Eiffel
  type definitions.
  This file is automatically included in the header for all modes of
  compilation: -boost, -no_check, -require_check, -ensure_check, ...
  This file is also included in the header of any cecil file (when the
  -cecil option is used).
  This file is also included in the header file of C++ wrappers (when
  using the external "C++" clause).
*/

#ifndef _BASE_H
#define _BASE_H

#if defined(_MSC_VER) && (_MSC_VER >= 1400)       /* VC8+ */
# ifndef _CRT_SECURE_NO_DEPRECATE
#  define _CRT_SECURE_NO_DEPRECATE
# endif
# ifndef _CRT_NONSTDC_NO_DEPRECATE
#  define _CRT_NONSTDC_NO_DEPRECATE
# endif
#endif   /* VC8+ */

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <signal.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <float.h>
#include <setjmp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  include <unistd.h>
#endif
#if !defined(WIN32) && \
       (defined(WINVER) || defined(_WIN32_WINNT) || defined(_WIN32) || \
	defined(__WIN32__) || defined(__TOS_WIN__) || defined(_MSC_VER))
#  define WIN32 1
#endif
#ifdef WIN32
#  include <windows.h>
#else
#  ifndef O_RDONLY
#    include <sys/file.h>
#  endif
#  ifndef O_RDONLY
#    define O_RDONLY 0000
#  endif
#endif

#if defined(_MSC_VER) && (_MSC_VER < 1500) /* MSVC older than v9 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "I64d"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c
#  define INT64_C(c) c ## i64
#elif defined(__WATCOMC__) && (__WATCOMC__ <= 1220) /* WATCOM 12.2 or lower */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__BORLANDC__) && (__BORLANDC__ < 0x600) /* Borland before 6.0 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "I64Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__FreeBSD__) && (__FreeBSD__ < 5) /* FreeBSD before 5.0 */ && !defined (_SYS_INTTYPES_H_)
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
#elif defined(__CYGWIN__) && defined(__BIT_TYPES_DEFINED__) /* Cygwin defines intxx_t in sys/types.h instead of inttypes.h */
#  include <cygwin/version.h>
#  if defined(CYGWIN_VERSION_DLL_MAJOR) && (CYGWIN_VERSION_DLL_MAJOR<1005)
typedef unsigned char uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
#  endif
#elif defined(SASC)
#    error("Too old SAS/C compiler, sorry.");
#elif defined(__SASC__)
#  if (__SASC__ < 750 ) /*  SAS/C before 7.50 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
#  endif
#else
#  include <inttypes.h>
#  if !defined(INT8_MAX) && defined(INT16_MAX)
/* int8_t is not mandatory */
typedef int_least8_t int8_t;
#  endif
#endif

#if !defined(PRId16)
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "lld"
#elif !defined(PRId8)
#  define PRId8 "d"
#endif
#if !defined(INT16_C)
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## LL
#elif !defined(INT8_C)
#  define INT8_C(c) c
#endif
#if !defined(INT16_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#  define INT8_MAX (INT8_C(127))
#  define INT16_MIN (-INT16_C(32767)-1)
#  define INT16_MAX (INT16_C(32767))
#  define INT32_MIN (-INT32_C(2147483647)-1)
#  define INT32_MAX (INT32_C(2147483647))
#  define INT64_MIN (-INT64_C(9223372036854775807)-1)
#  define INT64_MAX (INT64_C(9223372036854775807))
#elif !defined(INT8_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#endif


/*
  Endian stuff
*/
#if defined(BSD) && (BSD >= 199103)
#  include <machine/endian.h>
#elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
/* bi-endian processor, current mode should be find in machine/endian.h file */
#  include <machine/endian.h>
#elif defined(linux)
#  include <endian.h>
#endif



#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)
#  define BYTE_ORDER      __BYTE_ORDER
#endif

#if !defined(LITTLE_ENDIAN) && defined(__LITTLE_ENDIAN)
#  define LITTLE_ENDIAN      __LITTLE_ENDIAN
#endif

#if !defined(BIG_ENDIAN) && defined(__BIG_ENDIAN)
#  define BIG_ENDIAN      __BIG_ENDIAN
#endif

#if !defined(LITTLE_ENDIAN)
#  define LITTLE_ENDIAN   1234    /* LSB first (vax, pc) */
#endif
#if !defined(BIG_ENDIAN)
#  define BIG_ENDIAN      4321    /* MSB first (IBM, net) */
#endif
#if !defined(PDP_ENDIAN)
#  define PDP_ENDIAN      3412    /* LSB first in word, MSW first in long */
#endif

#if !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_RIGHT)
#  define BYTE_ORDER      LITTLE_ENDIAN
#elif !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_LEFT)
#  define BYTE_ORDER      BIG_ENDIAN
#elif !defined(BYTE_ORDER)

/* ARM */
#  if defined(__ARMEL__)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  elif defined(__ARMEB__)
#    define BYTE_ORDER      BIG_ENDIAN
#  elif defined(__arm__)
#    error "ARMs are bi-endian processors. Endianness is unknown for this system, please drop an e-mail to SmartEiffel@loria.fr"
#  endif

/* HP RISC */
#  if defined(__hppa__) || defined(__hppa) || defined(__hp9000) || \
      defined(__hp9000s300) || defined(hp9000s300) || \
      defined(__hp9000s700) || defined(hp9000s700) || \
      defined(__hp9000s800) || defined(hp9000s800) || defined(hp9000s820)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* IBM */
#  if defined(ibm032) || defined(ibm370) || defined(_IBMR2) || \
      defined(IBM370) || defined(__MVS__)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Intel x86 */
#  if defined(i386) || defined(__i386__) || defined(__i386) || \
      defined(_M_IX86) || defined(_X86_) || defined(__THW_INTEL) || \
      defined(sun386)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Intel Itanium */
#  if defined(__ia64__) || defined(_IA64) || defined(__IA64__) || \
      defined(_M_IA64)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Nationnal Semiconductor 32000 serie */
#  if  defined(ns32000)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Motorola 68000 */
#  if defined(mc68000) || defined(is68k) || defined(macII) || defined(m68k)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* MIPS */
#  if defined(MIPSEL) || defined(_MIPSEL)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  elif defined(MIPSEB) || defined(_MIPSEB)
#    define BYTE_ORDER      BIG_ENDIAN
#  elif defined(__mips__) || defined(__mips) || defined(__MIPS__)
#    error "MIPS are bi-endian processors. Endianness is unknown for this system, please drop an e-mail to SmartEiffel@loria.fr"
#  endif

/* Power PC */
/* this processor is bi-endian, how to know if little-endian is set? */
#  if defined(__powerpc) || defined(__powerpc__) || defined(__POWERPC__) || \
      defined(__ppc__) || defined(__ppc) || defined(_M_PPC) || \
      defined(__PPC) || defined(__PPC__)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Pyramid 9810 */
#  if defined(pyr)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* RS/6000 */
#  if defined(__THW_RS6000) || defined(_IBMR2) || defined(_POWER) || \
      defined(_ARCH_PWR) || defined(_ARCH_PWR2)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* SPARC */
#  if defined(__sparc__) || defined(sparc) || defined(__sparc)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* CCI Tahoe */
#  if defined(tahoe)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* VAX */
#  if defined(vax) || defined(VAX) || defined(__vax__) || defined(_vax_) || \
      defined(__vax) || defined(__VAX)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* ELATE is a virtual OS with a little endian Virtual Processor */
#  if defined(__ELATE__)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous little endian */
#  if defined(wrltitan)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous big endian */
#  if defined(apollo) || defined(__convex__) || defined(_CRAY) || defined(sel)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif
#endif


#if !defined(BYTE_ORDER)
#  error "Unknown byte order. Add your system in above macros once you know your system type. Please drop an e-mail to SmartEiffel@loria.fr"
#endif
#if (BYTE_ORDER != BIG_ENDIAN && BYTE_ORDER != LITTLE_ENDIAN)
#  error "Only little-endian and big-endian are valid at this time. Please drop an e-mail to SmartEiffel@loria.fr"
#endif


/*
  Byte swapping stuff
*/
extern void copy_swap_16(const uint16_t *src, uint16_t *dest, int count);


/* Because ANSI C EXIT_* are not always defined: */
#ifndef EXIT_FAILURE
#  define EXIT_FAILURE 1
#endif
#ifndef EXIT_SUCCESS
#  define EXIT_SUCCESS 0
#endif

/*
   On Linux glibc systems, we need to use sig.* versions of jmp_buf,
   setjmp and longjmp to preserve the signal handling context.
   Currently, the way I figured to detect this is if _SIGSET_H_types has
   been defined in /usr/include/setjmp.h.

   NOTE: with gcc, -ansi is used for SmartEiffel generated files EXCEPT in
   -no_split mode. ANSI only recognizes the non-sig versions.
*/
#if (defined(_SIGSET_H_types) && !defined(__STRICT_ANSI__))
#  define JMP_BUF    sigjmp_buf
#  define SETJMP(x)  sigsetjmp( (x), 1)
#  define LONGJMP    siglongjmp
#else
#  define JMP_BUF    jmp_buf
#  define SETJMP(x)  setjmp( (x) )
#  define LONGJMP    longjmp
#endif

/*
   Type to store reference objects Id:
 */
typedef int Tid;
typedef struct S0 T0;
struct S0{Tid id;};

/*
   The default channel used to print runtime error messages:
*/
#define SE_ERR stderr

/*
   Eiffel type INTEGER_8 is #1:
*/
typedef int8_t T1;
#define EIF_INTEGER_8 T1
#define M1 (INT8_C(0))
#define EIF_INTEGER_8_BITS (CHAR_BIT)
#define EIF_MINIMUM_INTEGER_8 (INT8_MIN)
#define EIF_MAXIMUM_INTEGER_8 (INT8_MAX)

/*
  Eiffel type INTEGER_16 is #10:
*/
typedef int16_t T10;
#define EIF_INTEGER_16 T10
#define M10 (INT16_C(0))
#define EIF_INTEGER_16_BITS (CHAR_BIT*sizeof(T10t))
#define EIF_MINIMUM_INTEGER_16 (INT16_MIN) /*-32768*/
#define EIF_MAXIMUM_INTEGER_16 (INT16_MAX) /*+32767*/

/*
  Eiffel type INTEGER or INTEGER_32 is #2:
*/
typedef int32_t T2;
#define EIF_INTEGER T2
#define EIF_INTEGER_32 T2
#define M2 (INT32_C(0))
#define EIF_INTEGER_BITS ((T2)(CHAR_BIT*sizeof(T2)))
#define EIF_INTEGER_32_BITS EIF_INTEGER_BITS
#define EIF_MINIMUM_INTEGER (INT32_MIN)
#define EIF_MAXIMUM_INTEGER (INT32_MAX)

/*
  Eiffel type INTEGER_64 is #11:
*/
typedef int64_t T11;
#define EIF_INTEGER_64 T11
#define M11 (INT64_C(0))
#define EIF_INTEGER_64_BITS (CHAR_BIT*sizeof(T11))
#define EIF_MINIMUM_INTEGER_64 (INT64_MIN)
#define EIF_MAXIMUM_INTEGER_64 (INT64_MAX)

/*
  Eiffel type CHARACTER is #3:
*/
typedef unsigned char T3;
#define EIF_CHARACTER T3
#define M3 (0)
#define EIF_CHARACTER_BITS (CHAR_BIT)
#define EIF_MINIMUM_CHARACTER_CODE (0)
#define EIF_MAXIMUM_CHARACTER_CODE (255)
#define T3code(x) ((T10)(x))
#define T3to_integer(x) ((signed char)(x))
#define T3to_integer_8(x) ((signed char)(x))
#define T3to_bit(x) (x)

/*
  Eiffel type REAL_32 is #4:
*/
typedef float T4;
typedef T4 real32_t;
#define EIF_REAL_32 T4
#define M4 (0.0)
#define EIF_MINIMUM_REAL_32 (-(FLT_MAX))
#define EIF_MAXIMUM_REAL_32 (FLT_MAX)

/*
  Eiffel type REAL or REAL_64 is #5:
*/
typedef double T5;
typedef T5 real64_t;
#define EIF_REAL_64 T5
#define M5 (0.0)
#define EIF_MINIMUM_REAL_64 (-(DBL_MAX))
#define EIF_MINIMUM_REAL (EIF_MINIMUM_REAL_64)
#define EIF_MAXIMUM_REAL_64 (DBL_MAX)
#define EIF_MAXIMUM_REAL (EIF_MAXIMUM_REAL_64)

/*
  Eiffel type REAL_EXTENDED is #12:
*/
typedef long double T12;
typedef T12 real_extended_t;
#define EIF_REAL_EXTENDED T12
#define M12 (0.0)
#define EIF_MINIMUM_REAL_EXTENDED (-(DBL_MAX))
#define EIF_MAXIMUM_REAL_EXTENDED (DBL_MAX)

/*
  Eiffel type BOOLEAN is #6:
*/
typedef char T6;
#define EIF_BOOLEAN T6
#define M6 (0)
#define EIF_BOOLEAN_BITS (CHAR_BIT)

/*
   Eiffel type POINTER is #8:
*/
typedef void* T8;
#define EIF_POINTER T8
/* Sometimes, NULL is defined as 0 */
#define M8 ((void*)NULL)
#define EIF_POINTER_BITS (CHAR_BIT*sizeof(void*))

/*
  To use type STRING on the C side:
*/
#define EIF_STRING T7*

/*
  Some Other EIF_* defined in ETL:
*/
#define eif_access(x) ((char*)(x))
#define EIF_REFERENCE T0*
#define EIF_OBJ T0*
#define EIF_OBJECT EIF_OBJ

/*
   Wrappers for `malloc' and `calloc':
*/
void* se_malloc(size_t size);
void* se_calloc(size_t nmemb, size_t size);
void* se_realloc(void* src, size_t size);

/*
   die method.
 */
void se_die(int code);

/*
    Runtime hooks. They allow different runtime modules to be quite independant. In time, they will also allow
    thread-safe operations.

    Currently known modules:
      - boost
      - no_check
      - sedb
      - gc
      - print stack
      - profile
      - plugins

    However, currently only profile uses this method. It will be extended to other modules later.

    The currently defined hooks are described in the enum below (the names should be self-explanatory).
 */
typedef enum {
  SE_HANDLE_EXCEPTION_SET, /* called when an exception handler is set, prior to SETJMP */
  SE_HANDLE_EXCEPTION_CLEAR, /* called when a feature with an exception handler normally returns */
  SE_HANDLE_EXCEPTION_THROWN, /* called when an exception is thrown, prior to the LONGJMP */
  SE_HANDLE_ENTER_GC, /* called when gc_start() begins */
  SE_HANDLE_EXIT_GC, /* called when gc_start() ends */
  SE_HANDLE_ENTER_PRINT_STACK, /* called when se_print_run_time_stack() begins */
  SE_HANDLE_EXIT_PRINT_STACK, /* called when se_print_run_time_stack() ends */
  SE_HANDLE_NO_MORE_MEMORY, /* called by se_alloc() and co */
  SE_HANDLE_SEDB_BREAK, /* called when sedb stops the program */
  SE_HANDLE_SEDB_CONTINUE, /* called when sedb continues the program */
  SE_HANDLE_RUNTIME_ERROR, /* called when a runtime error is raised and not caught by an exception. Cannot be raised in boost mode. */
  SE_HANDLE_DIE_WITH_CODE, /* called when the program is stopped by the die_with_code feature. The data points to the int code. */
  SE_HANDLE_NORMAL_EXIT /* called when the program correctly terminates. The data is null. */
} se_handler_action_t;

extern int handlers_count;
typedef void se_runtime_handler_t(se_handler_action_t action, void*data);
void register_handler(se_runtime_handler_t*handler);
void _handle(se_handler_action_t action, void*data);

#define handle(action,data) do{if(handlers_count>0)_handle(action,data);}while(0)

#endif /* #ifndef _BASE_H */
#define SE_BOOST 1
#define SE_GC_LIB 1
/* C Header Pass 1: */
typedef union _se_agent se_agent;
typedef struct _se_agent0 se_agent0;
typedef struct S233 T233;
typedef struct S232 T232;
typedef struct S72 T72;
typedef struct S230 T230;
typedef struct S139 T139;
typedef struct S226 T226;
typedef struct S183 T183;
typedef struct S178 T178;
typedef struct S141 T141;
typedef struct S144 T144;
typedef struct S221 T221;
typedef struct S218 T218;
typedef struct S222 T222;
typedef struct S220 T220;
typedef struct S219 T219;
typedef struct S217 T217;
typedef void*T187;
typedef struct S215 T215;
typedef void*T186;
typedef struct S213 T213;
typedef struct S140 T140;
typedef struct S205 T205;
typedef void*T154;
typedef struct S195 T195;
typedef struct S173 T173;
typedef struct S184 T184;
typedef struct S182 T182;
typedef struct S181 T181;
typedef struct S174 T174;
typedef struct S180 T180;
typedef struct S209 T209;
typedef struct S143 T143;
typedef struct S142 T142;
typedef struct S208 T208;
typedef struct S204 T204;
typedef struct S203 T203;
typedef struct S202 T202;
typedef struct S7 T7;
typedef int T199;
typedef struct S92 T92;
typedef struct S169 T169;
typedef struct S168 T168;
typedef struct S167 T167;
typedef struct S198 T198;
typedef struct S166 T166;
typedef struct S165 T165;
typedef int T93;
typedef struct S196 T196;
typedef struct S107 T107;
typedef void*T170;
typedef struct S96 T96;
typedef struct S193 T193;
typedef struct S49 T49;
typedef struct S191 T191;
typedef struct S118 T118;
typedef struct S117 T117;
typedef struct S116 T116;
typedef struct S115 T115;
typedef struct S73 T73;
typedef struct S114 T114;
typedef struct S112 T112;
typedef struct S110 T110;
typedef struct S171 T171;
typedef struct S57 T57;
typedef struct S100 T100;
typedef struct S51 T51;
typedef void*T39;
typedef T0 T189;
typedef struct S188 T188;
typedef struct S66 T66;
typedef void*T25;
/* C Header Pass 2: */
typedef T10*T234;
#define M234 NULL
typedef T2*T231;
#define M231 NULL
typedef T0**T228;
#define M228 NULL
typedef T0**T224;
#define M224 NULL
typedef T0**T223;
#define M223 NULL
typedef T0**T212;
#define M212 NULL
typedef T0**T211;
#define M211 NULL
typedef T0**T210;
#define M210 NULL
typedef T0**T207;
#define M207 NULL
typedef T0**T206;
#define M206 NULL
typedef T0**T201;
#define M201 NULL
typedef T0**T192;
#define M192 NULL
typedef T3*T9;
#define M9 NULL
/* C Header Pass 3: */
extern T199 M199;
struct S92{T8 _directory_stream;T8 _current_entry;} __attribute__((packed));
int se_cmpT92(T92 o1,T92 o2);
/* C Header Pass 4: */
struct S233{T231 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T233 M233;
struct S232{T234 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T232 M232;
struct S72{T234 _storage;T2 _count;T2 _capacity;T0* _low_surrogate_indexes;T0* _low_surrogate_values;} __attribute__((packed));
extern T72 M72;
struct S230{T231 _storage;T2 _capacity;T2 _upper;T2 _lower;} __attribute__((packed));
extern T230 M230;
struct S226{T228 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T226 M226;
struct S183{Tid id;T0* _path;T3 _drive;T0* _to_string_cache;T6 _valid_cache;} __attribute__((packed));
extern T183 M183;
struct S178{Tid id;T0* _to_string;} __attribute__((packed));
extern T178 M178;
struct S141{T0* _langage;T0* _nom;T0* _contenu;} __attribute__((packed));
extern T141 M141;
struct S144{Tid id;T0* _filter;T0* _path;T11 _flushed_character_count;T9 _buffer;T2 _buffer_position;T2 _capacity;T8 _output_stream;} __attribute__((packed));
extern T144 M144;
struct S222{T0* _arbre;T0* _couleur;T0* _pere;T0* _fils_gauche;T0* _fils_droite;T0* _etiquette;} __attribute__((packed));
extern T222 M222;
struct S221{T0* _arbre;T0* _noeud;} __attribute__((packed));
extern T221 M221;
struct S220{T224 _storage;T2 _capacity;T2 _upper;T2 _lower;} __attribute__((packed));
extern T220 M220;
struct S219{T0* _arbre;T0* _couleur;T0* _pere;T0* _fils_gauche;T0* _fils_droite;T0* _etiquette;} __attribute__((packed));
extern T219 M219;
struct S218{T0* _arbre;T0* _noeud;} __attribute__((packed));
extern T218 M218;
struct S217{T223 _storage;T2 _capacity;T2 _upper;T2 _lower;} __attribute__((packed));
extern T217 M217;
extern T187 M187;
struct S139{T0* _contenu;} __attribute__((packed));
extern T139 M139;
struct S215{T0* _ordre;T2 _nb_element;T0* _racine;T0* _nil;T0* _pointeurs;} __attribute__((packed));
extern T215 M215;
extern T186 M186;
struct S213{T0* _ordre;T2 _nb_element;T0* _racine;T0* _nil;T0* _pointeurs;} __attribute__((packed));
extern T213 M213;
extern T154 M154;
struct S173{Tid id;} __attribute__((packed));
extern T173 M173;
struct S184{Tid id;} __attribute__((packed));
extern T184 M184;
struct S182{Tid id;} __attribute__((packed));
extern T182 M182;
struct S181{Tid id;} __attribute__((packed));
extern T181 M181;
struct S174{Tid id;} __attribute__((packed));
extern T174 M174;
struct S180{Tid id;} __attribute__((packed));
extern T180 M180;
struct S209{T0* _item;} __attribute__((packed));
extern T209 M209;
struct S143{T6 _est_active_memoire;T0* _dico_ligne;T0* _dico_source;} __attribute__((packed));
extern T143 M143;
struct S142{T0* _fichier;T0* _tampon;T2 _indice;} __attribute__((packed));
extern T142 M142;
struct S140{T0* _lexeme;T6 _est_code;} __attribute__((packed));
extern T140 M140;
struct S208{T212 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T208 M208;
struct S205{T0* _item_1;T0* _item_2;} __attribute__((packed));
extern T205 M205;
struct S204{T211 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T204 M204;
struct S203{T0* _arbre;T0* _couleur;T0* _pere;T0* _fils_gauche;T0* _fils_droite;T0* _etiquette;} __attribute__((packed));
extern T203 M203;
struct S202{T210 _storage;T2 _capacity;T2 _upper;T2 _lower;} __attribute__((packed));
extern T202 M202;
extern T92 M92;
struct S169{Tid id;T6 _code_pris_en_compte;T6 _commentaire_pris_en_compte;T0* _fabrique;T0* _fichier;T0* _chaine;T0* _ligne;T0* _listage;T2 _indice_ligne;T6 _erreur;T0* _message_erreur;T0* _avant;T2 _etat;} __attribute__((packed));
extern T169 M169;
struct S168{Tid id;T6 _code_pris_en_compte;T6 _commentaire_pris_en_compte;T0* _fabrique;T0* _fichier;T0* _chaine;T0* _ligne;T0* _listage;T2 _indice_ligne;T6 _erreur;T0* _message_erreur;T0* _langage;T2 _etat;} __attribute__((packed));
extern T168 M168;
struct S167{Tid id;T6 _code_pris_en_compte;T6 _commentaire_pris_en_compte;T0* _fabrique;T0* _fichier;T0* _chaine;T0* _ligne;T0* _listage;T2 _indice_ligne;T6 _erreur;T0* _message_erreur;T2 _etat;T0* _chaine_litterale;} __attribute__((packed));
extern T167 M167;
struct S198{Tid id;T207 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T198 M198;
struct S166{Tid id;T2 _effort;} __attribute__((packed));
extern T166 M166;
struct S165{Tid id;T2 _a;T2 _n;T2 _c;} __attribute__((packed));
extern T165 M165;
extern T93 M93;
struct S196{Tid id;T206 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T196 M196;
struct S195{T0* _arbre;T0* _noeud;} __attribute__((packed));
extern T195 M195;
struct S107{T6 _est_ouvert;T2 _ligne;T2 _colonne;T0* _fichier;T0* _flux;T0* _associations;} __attribute__((packed));
extern T107 M107;
extern T170 M170;
struct S96{T0* _suffixe;T0* _langage;} __attribute__((packed));
extern T96 M96;
struct S193{T0* _ordre;T2 _nb_element;T0* _racine;T0* _nil;T0* _pointeurs;} __attribute__((packed));
extern T193 M193;
struct S49{Tid id;T2 _buffer_position;T9 _buffer;T2 _capacity;} __attribute__((packed));
extern T49 M49;
struct S191{T201 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T191 M191;
struct S118{Tid id;T0* _entree;T0* _entree_courte;T6 _est_epuise;T2 _lg_racine;T0* _fichiers;T2 _ligne;} __attribute__((packed));
extern T118 M118;
struct S117{Tid id;T0* _analyseur;T0* _nom_but;T0* _nom_nid;} __attribute__((packed));
extern T117 M117;
struct S116{Tid id;T0* _analyseur;T0* _nom_fichier;} __attribute__((packed));
extern T116 M116;
struct S115{Tid id;T0* _entree;T0* _flux;} __attribute__((packed));
extern T115 M115;
struct S73{T0* _filter;T0* _path;T6 _end_of_input;T3 _filtered_last_character;T8 _input_stream;T9 _buffer;T6 _end_reached;T2 _buffer_size;T2 _buffer_position;T2 _capacity;} __attribute__((packed));
extern T73 M73;
struct S114{Tid id;T0* _entree;T0* _entree_courte;} __attribute__((packed));
extern T114 M114;
struct S112{T0* _path;T6 _last_scan_status;T92 _basic_directory;T0* _name_list;} __attribute__((packed));
extern T112 M112;
struct S110{Tid id;T0* _analyseur;T0* _nom_fichier;} __attribute__((packed));
extern T110 M110;
struct S171{Tid id;} __attribute__((packed));
extern T171 M171;
struct S57{T0* _metrique;T0* _filtre_analyse;T0* _filtre_differentiel;T0* _filtre_unitaire;T6 _sortie_compacte;T0* _analyseur_force;T0* _associations;T6 _configuration_par_defaut;} __attribute__((packed));
extern T57 M57;
struct S100{T6 _code;T6 _commentaire;T6 _total;} __attribute__((packed));
extern T100 M100;
struct S51{T0* _default_message_catalog_directory;} __attribute__((packed));
extern T51 M51;
struct S7{T9 _storage;T2 _count;T2 _capacity;} __attribute__((packed));
extern T7 M7;
extern T39 M39;
struct S188{T192 _storage;T2 _capacity;T2 _upper;} __attribute__((packed));
extern T188 M188;
struct S66{T0* _commandes;} __attribute__((packed));
extern T66 M66;
extern T25 M25;
extern char*s26_0;
extern char*s116_41;
extern char*s118_46;
extern char*s57_99;
extern char*s107_881684455;
extern char*s165_430693;
extern char*s141_190;
extern char*s116_200;
extern char*s57_207;
extern char*s117_237;
extern char*s57_252;
extern char*s140_166353;
extern char*s118_276;
extern char*s168_198117854;
extern char*s57_297;
extern char*s57_1914603628;
extern char*s66_322;
extern char*s57_329;
extern char*s57_331;
extern char*s57_334;
extern char*s117_363254;
extern char*s165_357;
extern char*s165_367;
extern char*s66_1055124467;
extern char*s57_215549874;
extern char*s116_178787;
extern char*s165_422;
extern char*s26_2030253;
extern char*s66_955293794;
extern char*s99_250303104;
extern char*s117_497;
extern char*s183_498;
extern char*s167_2117014773;
extern char*s66_1489194569;
extern char*s66_174479840;
extern char*s107_402183751;
extern char*s13_1432888418;
extern char*s141_21314053;
extern char*s167_302894533;
extern char*s99_1469960689;
extern char*s167_1750975282;
extern char*s66_667384374;
extern char*s57_2067555065;
extern char*s57_1022;
extern char*s110_689122201;
extern char*s168_510417238;
extern char*s99_1122;
extern char*s66_2038516345;
extern char*s66_184721825;
extern char*s117_1159;
extern char*s107_438530588;
extern char*s13_1210;
extern char*s57_1815775;
extern char*s168_509162564;
extern char*s167_896478796;
extern char*s57_338767662;
extern char*s57_1347;
extern char*s66_105509483;
extern char*s57_1130825850;
extern char*s167_1835982646;
extern char*s66_1426;
extern char*s117_1871339;
extern char*s169_998148855;
extern char*s57_1636333591;
extern char*s167_156993542;
extern char*s66_1206126564;
extern char*s66_1823520895;
extern char*s167_1882109223;
extern char*s66_1652658481;
extern char*s167_1283315574;
extern char*s166_1477962;
extern char*s6_14036;
extern char*s57_1744;
extern char*s66_1511357824;
extern char*s57_1774;
extern char*s107_1655531153;
extern char*s110_482012695;
extern char*s66_709525889;
extern char*s169_1594537947;
extern char*s166_395586;
extern char*s168_1760805737;
extern char*s110_139149946;
extern char*s66_45085;
extern char*s116_949372;
extern char*s25_866438147;
extern char*s168_2126858037;
extern char*s167_249419393;
extern char*s107_1933550935;
extern char*s57_8773;
extern char*s169_10797639;
extern char*s57_8790;
extern char*s169_727364563;
extern char*s57_778583985;
extern char*s57_2733;
extern char*s57_8897;
extern char*s57_1872750;
extern char*s168_155715434;
extern char*s57_9022;
extern char*s57_72793912;
extern char*s179_1182938696;
extern char*s167_238286578;
extern char*s66_177674639;
extern char*s117_45440454;
extern char*s169_3022;
extern char*s66_494198994;
extern char*s57_1308013269;
extern char*s25_1860139408;
extern char*s169_141014885;
extern char*s169_619685758;
extern char*s66_402629279;
extern char*s167_1187496964;
extern char*s167_633654814;
extern char*s57_15751;
extern char*s167_397163;
extern char*s66_1209197973;
extern char*s167_2094708289;
extern char*s66_452763;
extern char*s57_89868;
extern char*s57_1326235;
extern char*s66_1679497459;
extern char*s66_575269952;
extern char*s116_22393487;
extern char*s6_59251;
extern char*s66_659784771;
extern char*s99_83912;
extern char*s57_1581702901;
extern char*s66_363423546;
extern char*s169_1916976;
extern char*s118_1839491374;
extern char*s57_155679758;
extern char*s57_1402518293;
extern char*s66_482439428;
extern char*s57_1978691;
extern char*s169_935023928;
extern char*s57_27714646;
extern char*s57_465093820;
extern char*s66_558072449;
extern char*s57_917949021;
extern char*s118_7613394;
extern char*s57_1945510587;
extern char*s57_2068456806;
extern char*s169_128695907;
extern char*s169_953440447;
extern char*s167_2038230808;
extern char*s168_276953473;
extern char*s57_78651488;
extern char*s25_1787719185;
extern char*s57_616531973;
extern char*s168_2137071568;
extern char*s167_1077131282;
extern char*s66_1196995941;
extern char*s107_1519585192;
extern char*s167_613991936;
extern char*s168_39279407;
extern char*s57_11429;
extern char*s57_1387148262;
extern char*s57_1148145250;
extern char*s66_1689211819;
extern char*s168_806032802;
extern char*s167_1632850237;
extern char*s57_5787;
extern char*s57_20654818;
extern char*s51_49306196;
extern char*s66_1293198338;
extern char*s140_134522190;
extern char*s66_356856294;
extern char*s57_2022577931;
extern char*s57_70779537;
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#define SE_BOOST 1
void se_print_run_time_stack (void);
void se_signal_handler(int sig);
#define FSOC_SIZE 8192
#define RSOC_SIZE 32768
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
   This file (SmartEiffel/sys/runtime/gc_lib.h) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has
   been selected).
*/

#define SE_GC_LIB 1

#define SE_GC_LOW_MEMORY_STRATEGY 0
#define SE_GC_HIGH_MEMORY_STRATEGY 1
#define SE_GC_DEFAULT_MEMORY_STRATEGY 2
extern int se_gc_strategy;


#define RSOH_UNMARKED 15253
#define RSOH_FREE 1
#define RSOH_MARKED 2


#define FSOH_UNMARKED ((void *) 1)
#define FSOH_MARKED   ((void *) 2)

/* To codify the state and the type of some Memory Chunk, we are
   using the following definitions :
*/
#define FSO_FREE_CHUNK  (-2)
#define RSO_FREE_CHUNK  (-1)
#define RSO_USED_CHUNK  ( 0)
#define FSO_STORE_CHUNK ( 1)
#define FSO_USED_CHUNK  ( 2)
#define FREE_CHUNK(x) ((x)<0)

/* Minimum size for a store area in a ReSizable Objects Chunk :
 */
#define RSOC_MIN_STORE 512

/* The default channel used to print -gc_info flag information :
*/
#define SE_GCINFO SE_ERR

extern int collector_counter; /* MEMORY.collector_counter */

typedef struct s_mch mch; /* Memory Chunk Header. */
typedef struct s_fsoc fsoc; /* Fixed Size Objects Chunk. */
typedef union u_rsoh rsoh; /* ReSizable Object Header. */
typedef struct s_fll_rsoh fll_rsoh;
typedef struct s_rsoc rsoc; /* ReSizable Objects Chunk. */
typedef struct s_na_env na_env; /* Native Array ENVironment. */


struct s_mch{
  unsigned int size; /* In number of bytes (actual argument of malloc).*/
  int state_type; /* One value in : RSO_USED_CHUNK,
                     FREE_CHUNK, FSO_STORE_CHUNK, FSO_USED_CHUNK */
  void(*amfp)(mch*,void*); /* Align Mark Function Pointer. */
  void(*swfp)(mch*); /* SWeep Function Pointer. */
};

struct s_fsoc{
  mch header; /* Common header for fsoc and rsoc. */
  fsoc* next; /* The next one when in free list (fsocfl). */
  int count_minus_one;
  double first_object;
};

typedef struct _rso_header rso_header;

struct _rso_header{
    unsigned int size;
    int magic_flag;     /* RSOH_MARKED when used,
			   RSOH_FREE when free,
			   else RSOH_UNMARKED */
};

typedef union u_fso_header fso_header;

union u_fso_header{
  void* flag;
  void* next;/* accurately typed as gcXX* in actual fso headers */
};

union u_rsoh{
  rso_header header;
  double padding;
};

struct s_fll_rsoh {
  rso_header rsoh_field;
  fll_rsoh* nextflol;
};

struct s_rsoc{
  mch header; /* Common header for fsoc and rsoc. */
  unsigned int isize; /* Initial size (at malloc time) to detect split chunks. */
  rsoc* next; /* Next one when in free list (rsocfl) or in na_env->chunk_list. */
  fll_rsoh*free_list_of_large; /* Intra. free list. */
  na_env*nae;
  rsoh first_header;
};

struct s_na_env{
  unsigned int store_left;
  rsoh* store;
  rsoc*store_chunk;
  rsoc*chunk_list; /*List of chunks of that type that have a non-null free_list_of_large*/
  void (*gc_mark)(T0*);
  int space_used;
};

extern void**stack_bottom;
extern mch**gcmt;
extern int gcmt_max;
extern int gcmt_used;
extern int gc_is_off;
extern fsoc* fsocfl;
extern unsigned int fsoc_count;
extern unsigned int rsoc_count;
extern void*gcmt_tail_addr;

void gc_sweep(void);
void gc_mark(void* p);
mch* gc_find_chunk(void* p);
int gc_stack_size(void);
int garbage_delayed(void);
void gc_update_ceils(void);
char*new_na(na_env*nae,unsigned int size);
unsigned int fsocfl_count(void);
unsigned int rsocfl_count(void);
void gc_dispose_before_exit(void);
void mark_stack_and_registers (void);
fsoc* gc_fsoc_get1(void);
fsoc* gc_fsoc_get2(void);

int gc_memory_used(void);
/*The generic se_agent0 definition:*/
struct _se_agent0{
Tid id;
Tid creation_mold_id;
void(*afp)(se_agent*);void(*gc_mark_agent_mold)(se_agent*);
int(*eq)(se_agent*,se_agent*);
};
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#include <errno.h>

#define text_file_read_open(p) (fopen(((char*)(p)),"r"))
#define text_file_write_open(p) (fopen(((char*)(p)),"w"))
#define text_file_write_append(p) (fopen(((char*)(p)),"a"))
#define text_file_read_write_open(p) (fopen(((char*)(p)),"r+"))
#define text_file_read_write_append(p) (fopen(((char*)(p)),"a+"))
#define binary_file_read_open(p) (fopen(((char*)(p)),"rb"))
#define binary_file_write_open(p) (fopen(((char*)(p)),"wb"))
#define binary_file_write_append(p) (fopen(((char*)(p)),"ab"))
#define io_fclose(p) (fclose((FILE*)(p)))
#define io_flush(p) (fflush((FILE*)(p)))
#define io_getc(f) (getc(((FILE*)(f))))
#define io_putc(b, f) (putc((b),((FILE*)(f))))
#define io_fread(b, n, f) (fread((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define io_fwrite(b, n, f) (fwrite((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define io_feof(f) (feof(((FILE*)(f))))
#define io_rename(o, n) (rename(((char*)(o)),((char*)(n))))
#define io_remove(f) (remove(((char*)(f))))
#define io_fseek(f, o) (fseek((FILE*)(f),(o),SEEK_SET))
#define io_ftell(f) ((EIF_INTEGER_64)ftell((FILE*)(f)))

#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  define read_stdin(b, s) (read(STDIN_FILENO, b, s))
#else
   extern int read_stdin(EIF_CHARACTER *buffer, int size);
#endif

extern void io_copy(char*source, char*target);
extern int io_file_exists(char*source);
extern int io_same_physical_file(char*path1,char*path2);
#include <libintl.h>
#include <locale.h>
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#ifndef WIN32
#  include <dirent.h>
#endif
#ifndef WIN32
#  include <unistd.h>
#endif

EIF_POINTER directory_open(EIF_POINTER path);
EIF_POINTER directory_read_entry(EIF_POINTER dirstream);
EIF_POINTER directory_get_entry_name(EIF_POINTER entry);
EIF_BOOLEAN directory_close(EIF_POINTER dirstream);
#define directory_current_working_directory (directory_cwd())
EIF_POINTER directory_cwd(void);
EIF_BOOLEAN directory_chdir(EIF_POINTER destination);
EIF_BOOLEAN directory_mkdir(EIF_POINTER directory_path);
EIF_BOOLEAN directory_rmdir(EIF_POINTER directory_path);
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#define basic_getenv(v) (getenv((char*)v))
extern unsigned int fsoc_count_ceil;
extern unsigned int rsoc_count_ceil;
/*INTEGER_64*/T3 r11decimal_digit(T11 C);
/*INTEGER_64*/void r11append_in(T11 C,T0* a1);
/*BOOLEAN*/T0* r6to_string(T6 C);
/*BOOLEAN*/T6 r6_ix_and(T6 C,T6 a1);
/*BOOLEAN*/T6 r6_ix_or(T6 C,T6 a1);
/*BOOLEAN*/void r6append_in(T6 C,T0* a1);
extern T0*oBC63string_buffer;
extern int fBC63string_buffer;
/*INTEGER_32*/T0* r2string_buffer(void);
/*INTEGER_32*/T6 r2is_even(T2 C);
/*INTEGER_32*/T6 r2is_odd(T2 C);
/*INTEGER_32*/T6 r2in_range(T2 C,T2 a1,T2 a2);
/*INTEGER_32*/T2 r2min(T2 C,T2 a1);
/*INTEGER_32*/T3 r2decimal_digit(T2 C);
/*INTEGER_32*/T2 r2max(T2 C,T2 a1);
/*INTEGER_32*/T0* r2to_string(T2 C);
/*INTEGER_32*/void r2append_in(T2 C,T0* a1);
/*INTEGER_32*/T2 r2_ix_45(T2 C,T2 a1);
/*CHARACTER*/T6 r3_ix_6261(T3 C,T3 a1);
/*CHARACTER*/T6 r3_ix_60(T3 C,T3 a1);
/*CHARACTER*/T6 r3in_range(T3 C,T3 a1,T3 a2);
/*CHARACTER*/T6 r3_ix_6061(T3 C,T3 a1);
/*CHARACTER*/T1 r3decimal_value(T3 C);
/*CHARACTER*/T1 r3hexadecimal_value(T3 C);
/*CHARACTER*/T3 r3to_lower(T3 C);
/*NATIVE_ARRAY[INTEGER_16]*/void r234copy_from(T234 C,T234 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER_16]*/void r234clear_all(T234 C,T2 a1);
/*NATIVE_ARRAY[INTEGER_16]*/T234 r234realloc(T234 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER_32]*/void r231copy_from(T231 C,T231 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER_32]*/T2 r231fast_index_of(T231 C,T2 a1,T2 a2,T2 a3);
/*NATIVE_ARRAY[INTEGER_32]*/void r231clear_all(T231 C,T2 a1);
/*NATIVE_ARRAY[INTEGER_32]*/void r231set_all_with(T231 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER_32]*/T231 r231realloc(T231 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_LIGNE]*/void r228copy_from(T228 C,T228 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_LIGNE]*/void r228clear(T228 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_LIGNE]*/T6 r228fast_memcmp(T228 C,T228 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_LIGNE]*/void r228clear_all(T228 C,T2 a1);
/*NATIVE_ARRAY[LUAT_LIGNE]*/T228 r228realloc(T228 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r224copy_from(T224 C,T224 a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/T2 r224fast_first_index_of(T224 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r224clear_all(T224 C,T2 a1);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r224set_all_with(T224 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/T224 r224realloc(T224 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r223copy_from(T223 C,T223 a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/T2 r223fast_first_index_of(T223 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r223clear_all(T223 C,T2 a1);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r223set_all_with(T223 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/T223 r223realloc(T223 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_SOURCE]*/void r212copy_from(T212 C,T212 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_SOURCE]*/void r212clear(T212 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_SOURCE]*/void r212clear_all(T212 C,T2 a1);
/*NATIVE_ARRAY[LUAT_SOURCE]*/T212 r212realloc(T212 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[TUPLE[STRING,STRING]]*/void r211copy_from(T211 C,T211 a1,T2 a2);
/*NATIVE_ARRAY[TUPLE[STRING,STRING]]*/void r211clear(T211 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[TUPLE[STRING,STRING]]*/void r211clear_all(T211 C,T2 a1);
/*NATIVE_ARRAY[TUPLE[STRING,STRING]]*/T211 r211realloc(T211 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r210copy_from(T210 C,T210 a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/T2 r210fast_first_index_of(T210 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r210clear_all(T210 C,T2 a1);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r210set_all_with(T210 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/T210 r210realloc(T210 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_ANALYSEUR]*/void r207copy_from(T207 C,T207 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_ANALYSEUR]*/void r207clear(T207 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_ANALYSEUR]*/void r207clear_all(T207 C,T2 a1);
/*NATIVE_ARRAY[LUAT_ANALYSEUR]*/T207 r207realloc(T207 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_METRIQUE]*/void r206copy_from(T206 C,T206 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_METRIQUE]*/void r206clear(T206 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_METRIQUE]*/void r206clear_all(T206 C,T2 a1);
/*NATIVE_ARRAY[LUAT_METRIQUE]*/T206 r206realloc(T206 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/void r201copy_from(T201 C,T201 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/void r201clear(T201 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/void r201clear_all(T201 C,T2 a1);
/*NATIVE_ARRAY[STRING]*/T201 r201realloc(T201 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_COMMANDE]*/void r192copy_from(T192 C,T192 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_COMMANDE]*/void r192clear(T192 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LUAT_COMMANDE]*/void r192clear_all(T192 C,T2 a1);
/*NATIVE_ARRAY[LUAT_COMMANDE]*/T192 r192realloc(T192 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9copy_from(T9 C,T9 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9clear(T9 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9copy_at(T9 C,T2 a1,T9 a2,T2 a3);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9fast_memcmp(T9 C,T9 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9slice_copy(T9 C,T2 a1,T9 a2,T2 a3,T2 a4);
/*NATIVE_ARRAY[CHARACTER]*/T2 r9fast_reverse_index_of(T9 C,T3 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9clear_all(T9 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/void r9set_all_with(T9 C,T3 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9fast_has(T9 C,T3 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9remove_first(T9 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/T9 r9realloc(T9 C,T2 a1,T2 a2);
/*STRING*/T0* r7_ix_43(T7* C,T0* a1);
/*STRING*/T6 r7is_equal(T7* C,T0* a1);
/*STRING*/void r7append(T7* C,T0* a1);
/*STRING*/void r7copy(T7* C,T0* a1);
/*STRING*/void r7make_empty(T7* C);
/*STRING*/T6 r7has_suffix(T7* C,T0* a1);
/*STRING*/void r7remove_tail(T7* C,T2 a1);
/*STRING*/void r7make(T7* C,T2 a1);
/*STRING*/void r7append_string(T7* C,T0* a1);
/*STRING*/void r7make_filled(T7* C,T3 a1,T2 a2);
/*STRING*/T2 r7compare(T7* C,T0* a1);
/*STRING*/T6 r7_ix_60(T7* C,T0* a1);
/*STRING*/T0* r7twin(T7* C);
/*STRING*/void r7append_substring(T7* C,T0* a1,T2 a2,T2 a3);
/*STRING*/T6 r7_ix_6061(T7* C,T0* a1);
/*STRING*/void r7extend(T7* C,T3 a1);
/*STRING*/void r7remove_last(T7* C);
/*STRING*/T6 r7has(T7* C,T3 a1);
/*STRING*/void r7keep_head(T7* C,T2 a1);
/*STRING*/void r7append_character(T7* C,T3 a1);
/*STRING*/void r7fill_with(T7* C,T3 a1);
/*STRING*/void r7extend_unless(T7* C,T3 a1);
/*STRING*/void r7add_last(T7* C,T3 a1);
/*STRING*/void r7resize(T7* C,T2 a1);
/*STRING*/void r7ensure_capacity(T7* C,T2 a1);
/*STRING*/void r7to_lower(T7* C);
/*STRING*/void r7from_external_copy(T7* C,T8 a1);
/*STRING*/void r7from_external(T7* C,T8 a1);
/*STRING*/T8 r7to_external(T7* C);
/*STRING*/T2 r7last_index_of(T7* C,T3 a1);
/*STRING*/void r7with_capacity(T7* C,T2 a1);
/*STRING*/T6 r7is_boolean(T7* C);
/*STRING*/void r7remove_head(T7* C,T2 a1);
/*STRING*/T3 r7first(T7* C);
/*STRING*/void r7swap(T7* C,T2 a1,T2 a2);
/*STRING*/T3 r7last(T7* C);
/*STRING*/T6 r7valid_index(T7* C,T2 a1);
/*STRING*/T0* r7substring(T7* C,T2 a1,T2 a2);
/*STRING*/T6 r7to_boolean(T7* C);
/*STRING*/T2 r7reverse_index_of(T7* C,T3 a1,T2 a2);
/*STRING*/void r7keep_tail(T7* C,T2 a1);
/*STRING*/void r7remove_first(T7* C);
/*STRING*/void r7put(T7* C,T3 a1,T2 a2);
/*STRING*/void r7remove_between(T7* C,T2 a1,T2 a2);
/*FAST_ARRAY[INTEGER_32]*/void r233make(T233* C,T2 a1);
/*FAST_ARRAY[INTEGER_32]*/void r233add_last(T233* C,T2 a1);
/*FAST_ARRAY[INTEGER_32]*/T2 r233fast_first_index_of(T233* C,T2 a1);
/*FAST_ARRAY[INTEGER_16]*/void r232make(T232* C,T2 a1);
/*FAST_ARRAY[INTEGER_16]*/void r232add_last(T232* C,T10 a1);
/*ARRAY[INTEGER_32]*/void r230make(T230* C,T2 a1,T2 a2);
/*ARRAY[INTEGER_32]*/void r230ensure_capacity_and_bounds(T230* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[INTEGER_32]*/T2 r230last(T230* C);
/*ARRAY[INTEGER_32]*/void r230clear_all(T230* C);
/*ARRAY[INTEGER_32]*/void r230set_all_with(T230* C,T2 a1);
/*ARRAY[INTEGER_32]*/T2 r230item(T230* C,T2 a1);
/*ARRAY[INTEGER_32]*/void r230put(T230* C,T2 a1,T2 a2);
/*FAST_ARRAY[LUAT_LIGNE]*/T6 r226is_equal(T226* C,T0* a1);
/*FAST_ARRAY[LUAT_LIGNE]*/void r226add_last(T226* C,T0* a1);
/*FAST_ARRAY[LUAT_LIGNE]*/void r226mark_native_arrays(T226* C);
/*FAST_ARRAY[LUAT_LIGNE]*/void r226with_capacity(T226* C,T2 a1);
/*FAST_ARRAY[LUAT_LIGNE]*/T2 r226count(T226* C);
/*FAST_ARRAY[LUAT_LIGNE]*/T0* r226item(T226* C,T2 a1);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r220remove_last(T220* C);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r220add_last(T220* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r220ensure_capacity_and_bounds(T220* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r220mark_native_arrays(T220* C);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r220with_capacity(T220* C,T2 a1,T2 a2);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/T2 r220count(T220* C);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/T2 r220fast_first_index_of(T220* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/T0* r220last(T220* C);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r220clear_all(T220* C);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/T0* r220item(T220* C,T2 a1);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r220set_all_with(T220* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_LIGNE]]*/void r220put(T220* C,T0* a1,T2 a2);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r217remove_last(T217* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r217add_last(T217* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r217ensure_capacity_and_bounds(T217* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r217mark_native_arrays(T217* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r217with_capacity(T217* C,T2 a1,T2 a2);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/T2 r217count(T217* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/T2 r217fast_first_index_of(T217* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/T0* r217last(T217* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r217clear_all(T217* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/T0* r217item(T217* C,T2 a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r217set_all_with(T217* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SOURCE]]*/void r217put(T217* C,T0* a1,T2 a2);
/*FAST_ARRAY[LUAT_SOURCE]*/void r208add_last(T208* C,T0* a1);
/*FAST_ARRAY[LUAT_SOURCE]*/void r208mark_native_arrays(T208* C);
/*FAST_ARRAY[LUAT_SOURCE]*/void r208with_capacity(T208* C,T2 a1);
/*FAST_ARRAY[LUAT_SOURCE]*/T2 r208count(T208* C);
/*FAST_ARRAY[LUAT_SOURCE]*/T6 r208is_empty(T208* C);
/*FAST_ARRAY[LUAT_SOURCE]*/T0* r208item(T208* C,T2 a1);
/*FAST_ARRAY[TUPLE[STRING,STRING]]*/void r204add_last(T204* C,T0* a1);
/*FAST_ARRAY[TUPLE[STRING,STRING]]*/void r204mark_native_arrays(T204* C);
/*FAST_ARRAY[TUPLE[STRING,STRING]]*/void r204with_capacity(T204* C,T2 a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r202remove_last(T202* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r202add_last(T202* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r202ensure_capacity_and_bounds(T202* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r202mark_native_arrays(T202* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r202with_capacity(T202* C,T2 a1,T2 a2);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/T2 r202count(T202* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/T2 r202fast_first_index_of(T202* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/T0* r202last(T202* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r202clear_all(T202* C);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/T0* r202item(T202* C,T2 a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r202set_all_with(T202* C,T0* a1);
/*ARRAY[ARN_ITERATEUR[LUAT_SUFFIXE]]*/void r202put(T202* C,T0* a1,T2 a2);
/*FAST_ARRAY[LUAT_ANALYSEUR]*/void r198add_last(T198* C,T0* a1);
/*FAST_ARRAY[LUAT_ANALYSEUR]*/void r198mark_native_arrays(T198* C);
/*FAST_ARRAY[LUAT_ANALYSEUR]*/void r198with_capacity(T198* C,T2 a1);
/*FAST_ARRAY[LUAT_ANALYSEUR]*/T6 r198valid_index(T198* C,T2 a1);
/*FAST_ARRAY[LUAT_ANALYSEUR]*/T0* r198item(T198* C,T2 a1);
/*FAST_ARRAY[LUAT_METRIQUE]*/void r196add_last(T196* C,T0* a1);
/*FAST_ARRAY[LUAT_METRIQUE]*/void r196mark_native_arrays(T196* C);
/*FAST_ARRAY[LUAT_METRIQUE]*/void r196with_capacity(T196* C,T2 a1);
/*FAST_ARRAY[LUAT_METRIQUE]*/T6 r196valid_index(T196* C,T2 a1);
/*FAST_ARRAY[LUAT_METRIQUE]*/T0* r196item(T196* C,T2 a1);
/*FAST_ARRAY[STRING]*/void r191make(T191* C,T2 a1);
/*FAST_ARRAY[STRING]*/void r191remove_last(T191* C);
/*FAST_ARRAY[STRING]*/void r191add_last(T191* C,T0* a1);
/*FAST_ARRAY[STRING]*/void r191mark_native_arrays(T191* C);
/*FAST_ARRAY[STRING]*/void r191with_capacity(T191* C,T2 a1);
/*FAST_ARRAY[STRING]*/void r191swap(T191* C,T2 a1,T2 a2);
/*FAST_ARRAY[STRING]*/T6 r191valid_index(T191* C,T2 a1);
/*FAST_ARRAY[STRING]*/T6 r191is_empty(T191* C);
/*FAST_ARRAY[STRING]*/T0* r191item(T191* C,T2 a1);
/*FAST_ARRAY[STRING]*/void r191put(T191* C,T0* a1,T2 a2);
/*FAST_ARRAY[LUAT_COMMANDE]*/void r188add_last(T188* C,T0* a1);
/*FAST_ARRAY[LUAT_COMMANDE]*/void r188mark_native_arrays(T188* C);
/*FAST_ARRAY[LUAT_COMMANDE]*/void r188with_capacity(T188* C,T2 a1);
/*FAST_ARRAY[LUAT_COMMANDE]*/T6 r188is_empty(T188* C);
/*FAST_ARRAY[LUAT_COMMANDE]*/T0* r188item(T188* C,T2 a1);
/*FAST_ARRAY[LUAT_COMMANDE]*/void r188do_all(T188* C,T0* a1);
/*ARN_NOEUD[LUAT_LIGNE]*/void r222initialiser_nil(T222* C);
/*ARN_NOEUD[LUAT_LIGNE]*/void r222fabriquer(T222* C,T0* a1);
/*ARN_NOEUD[LUAT_LIGNE]*/void r222initialiser(T222* C);
/*ARN_NOEUD[LUAT_LIGNE]*/void r222fabriquer_nil(T222* C,T0* a1);
/*ARN_ITERATEUR[LUAT_LIGNE]*/void r221pointer_hors_borne(T221* C);
/*ARN_ITERATEUR[LUAT_LIGNE]*/T6 r221est_hors_borne(T221* C);
/*ARN_ITERATEUR[LUAT_LIGNE]*/void r221detacher(T221* C);
/*ARN_ITERATEUR[LUAT_LIGNE]*/void r221attacher(T221* C,T0* a1);
/*ARN_NOEUD[LUAT_SOURCE]*/void r219initialiser_nil(T219* C);
/*ARN_NOEUD[LUAT_SOURCE]*/void r219fabriquer(T219* C,T0* a1);
/*ARN_NOEUD[LUAT_SOURCE]*/void r219initialiser(T219* C);
/*ARN_NOEUD[LUAT_SOURCE]*/void r219fabriquer_nil(T219* C,T0* a1);
/*ARN_ITERATEUR[LUAT_SOURCE]*/void r218pointer_hors_borne(T218* C);
/*ARN_ITERATEUR[LUAT_SOURCE]*/T6 r218est_hors_borne(T218* C);
/*ARN_ITERATEUR[LUAT_SOURCE]*/void r218detacher(T218* C);
/*ARN_ITERATEUR[LUAT_SOURCE]*/void r218attacher(T218* C,T0* a1);
/*ARN_ARBRE[LUAT_LIGNE]*/void r215fabriquer(T215* C,T0* a1);
/*ARN_ARBRE[LUAT_LIGNE]*/void r215ajouter(T215* C,T0* a1);
/*ARN_ARBRE[LUAT_LIGNE]*/void r215vider(T215* C);
/*ARN_ARBRE[LUAT_LIGNE]*/void r215trouver(T215* C,T0* a1,T0* a2);
/*ARN_ARBRE[LUAT_LIGNE]*/T6 r215est_vide(T215* C);
/*ARN_ARBRE[LUAT_LIGNE]*/T0* r215i_trouver(T215* C,T0* a1);
/*ARN_ARBRE[LUAT_LIGNE]*/void r215oublier(T215* C,T0* a1);
/*ARN_ARBRE[LUAT_LIGNE]*/void r215rotation_droite(T215* C,T0* a1);
/*ARN_ARBRE[LUAT_LIGNE]*/void r215rotation_gauche(T215* C,T0* a1);
/*ARN_ARBRE[LUAT_LIGNE]*/void r215i_inserer(T215* C,T0* a1);
/*ARN_ARBRE[LUAT_SOURCE]*/void r213fabriquer(T213* C,T0* a1);
/*ARN_ARBRE[LUAT_SOURCE]*/void r213ajouter(T213* C,T0* a1);
/*ARN_ARBRE[LUAT_SOURCE]*/void r213vider(T213* C);
/*ARN_ARBRE[LUAT_SOURCE]*/void r213trouver(T213* C,T0* a1,T0* a2);
/*ARN_ARBRE[LUAT_SOURCE]*/T6 r213est_vide(T213* C);
/*ARN_ARBRE[LUAT_SOURCE]*/T0* r213i_trouver(T213* C,T0* a1);
/*ARN_ARBRE[LUAT_SOURCE]*/void r213oublier(T213* C,T0* a1);
/*ARN_ARBRE[LUAT_SOURCE]*/void r213rotation_droite(T213* C,T0* a1);
/*ARN_ARBRE[LUAT_SOURCE]*/void r213rotation_gauche(T213* C,T0* a1);
/*ARN_ARBRE[LUAT_SOURCE]*/void r213i_inserer(T213* C,T0* a1);
T205*create205make_2(T0* a1,T0* a2);
/*TUPLE[STRING,STRING]*/void r205make_2(T205* C,T0* a1,T0* a2);
/*ARN_NOEUD[LUAT_SUFFIXE]*/T0* r203minimum(T203* C);
/*ARN_NOEUD[LUAT_SUFFIXE]*/void r203initialiser_nil(T203* C);
/*ARN_NOEUD[LUAT_SUFFIXE]*/void r203fabriquer(T203* C,T0* a1);
/*ARN_NOEUD[LUAT_SUFFIXE]*/void r203initialiser(T203* C);
/*ARN_NOEUD[LUAT_SUFFIXE]*/T0* r203successeur(T203* C);
/*ARN_NOEUD[LUAT_SUFFIXE]*/void r203fabriquer_nil(T203* C,T0* a1);
/*COLLECTION_SORTER[STRING]*/void r199quick_sort(T0* a1);
/*COLLECTION_SORTER[STRING]*/T6 r199lt(T0* a1,T0* a2);
/*COLLECTION_SORTER[STRING]*/void r199sort(T0* a1);
/*COLLECTION_SORTER[STRING]*/T6 r199lte(T0* a1,T0* a2);
/*COLLECTION_SORTER[STRING]*/void r199quick_sort_region(T0* a1,T2 a2,T2 a3);
/*COLLECTION_SORTER[STRING]*/T6 r199is_sorted(T0* a1);
/*ARN_ITERATEUR[LUAT_SUFFIXE]*/void r195pointer_hors_borne(T195* C);
/*ARN_ITERATEUR[LUAT_SUFFIXE]*/void r195pointer_premier(T195* C);
/*ARN_ITERATEUR[LUAT_SUFFIXE]*/T6 r195est_hors_borne(T195* C);
/*ARN_ITERATEUR[LUAT_SUFFIXE]*/void r195avancer(T195* C);
/*ARN_ITERATEUR[LUAT_SUFFIXE]*/void r195detacher(T195* C);
/*ARN_ITERATEUR[LUAT_SUFFIXE]*/void r195attacher(T195* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r193fabriquer(T193* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r193ajouter(T193* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r193retirer(T193* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r193trouver(T193* C,T0* a1,T0* a2);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r193deplacer(T193* C,T0* a1,T0* a2);
/*ARN_ARBRE[LUAT_SUFFIXE]*/T0* r193i_trouver(T193* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r193oublier(T193* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r193rotation_droite(T193* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r193reformer(T193* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r193rotation_gauche(T193* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r193i_retirer(T193* C,T0* a1);
/*ARN_ARBRE[LUAT_SUFFIXE]*/void r193i_inserer(T193* C,T0* a1);
/*UNICODE_STRING*/void r72make_empty(T72* C);
/*UNICODE_STRING*/void r72make(T72* C,T2 a1);
/*UNICODE_STRING*/T6 r72valid_unicode(T2 a1);
/*UNICODE_STRING*/T10 r72low_surrogate_value(T72* C,T2 a1);
/*UNICODE_STRING*/void r72clear_count(T72* C);
/*UNICODE_STRING*/void r72utf8_encode_in(T72* C,T0* a1);
/*UNICODE_STRING*/void r72add_last(T72* C,T2 a1);
/*UNICODE_STRING*/T2 r72item(T72* C,T2 a1);
/*MICROSOFT_PATH_NAME*/void r183make_from_string(T183* C,T0* a1);
/*MICROSOFT_PATH_NAME*/void r183make_empty(T183* C);
/*MICROSOFT_PATH_NAME*/void r183join_up(T183* C);
/*MICROSOFT_PATH_NAME*/void r183start_join(T183* C,T0* a1,T2 a2);
/*MICROSOFT_PATH_NAME*/void r183end_join(T183* C);
/*MICROSOFT_PATH_NAME*/void r183join_element(T183* C,T0* a1);
/*MICROSOFT_PATH_NAME*/void r183join_directory(T183* C,T0* a1);
/*MICROSOFT_PATH_NAME*/void r183remove_last(T183* C);
/*MICROSOFT_PATH_NAME*/T0* r183drive_specification(T183* C);
/*MICROSOFT_PATH_NAME*/T6 r183is_absolute(T183* C);
/*MICROSOFT_PATH_NAME*/void r183go_up(T183* C);
/*MICROSOFT_PATH_NAME*/void r183make_current(T183* C);
/*MICROSOFT_PATH_NAME*/void r183join_to(T183* C,T0* a1);
/*MICROSOFT_PATH_NAME*/void r183add_last(T183* C,T0* a1);
/*MICROSOFT_PATH_NAME*/T6 r183is_separator(T3 a1);
/*MICROSOFT_PATH_NAME*/void r183join(T183* C,T0* a1);
/*MICROSOFT_PATH_NAME*/void r183make_root(T183* C);
/*MICROSOFT_PATH_NAME*/void r183join_directory_to(T0* a1,T0* a2);
/*MICROSOFT_PATH_NAME*/void r183join_element_to(T0* a1,T0* a2);
/*MICROSOFT_PATH_NAME*/T2 r183start_join_to(T183* C,T0* a1);
/*MICROSOFT_PATH_NAME*/T2 r183scan_element(T183* C,T2 a1,T0* a2);
/*MICROSOFT_PATH_NAME*/T0* r183to_string(T183* C);
/*MICROSOFT_PATH_NAME*/T2 r183count(T183* C);
/*MICROSOFT_PATH_NAME*/T0* r183last(T183* C);
/*MICROSOFT_PATH_NAME*/void r183_P_179_join_element(T183* C,T0* a1);
/*MICROSOFT_PATH_NAME*/void r183_P_177_end_join(T183* C);
/*POSIX_PATH_NAME*/void r178make_from_string(T178* C,T0* a1);
/*POSIX_PATH_NAME*/void r178make_empty(T178* C);
/*POSIX_PATH_NAME*/void r178join_up(T178* C);
/*POSIX_PATH_NAME*/void r178start_join(T178* C,T0* a1,T2 a2);
/*POSIX_PATH_NAME*/void r178end_join(T178* C);
/*POSIX_PATH_NAME*/void r178join_element(T178* C,T0* a1);
/*POSIX_PATH_NAME*/void r178join_directory(T178* C,T0* a1);
/*POSIX_PATH_NAME*/void r178remove_last(T178* C);
/*POSIX_PATH_NAME*/T6 r178is_absolute(T178* C);
/*POSIX_PATH_NAME*/void r178go_up(T178* C);
/*POSIX_PATH_NAME*/void r178make_current(T178* C);
/*POSIX_PATH_NAME*/void r178join_to(T178* C,T0* a1);
/*POSIX_PATH_NAME*/void r178add_last(T178* C,T0* a1);
/*POSIX_PATH_NAME*/T6 r178is_separator(T3 a1);
/*POSIX_PATH_NAME*/void r178join(T178* C,T0* a1);
/*POSIX_PATH_NAME*/void r178make_root(T178* C);
/*POSIX_PATH_NAME*/void r178join_directory_to(T0* a1,T0* a2);
/*POSIX_PATH_NAME*/void r178join_element_to(T0* a1,T0* a2);
/*POSIX_PATH_NAME*/T2 r178start_join_to(T178* C,T0* a1);
/*POSIX_PATH_NAME*/T2 r178scan_element(T178* C,T2 a1,T0* a2);
/*POSIX_PATH_NAME*/T2 r178count(T178* C);
/*POSIX_PATH_NAME*/T0* r178last(T178* C);
/*LUAT_LISTAGE*/void r141fabriquer(T141* C,T0* a1,T0* a2);
/*LUAT_LISTAGE*/T2 r141nb_ligne(T141* C);
/*LUAT_LISTAGE*/T2 r141nb_ligne_code(T141* C);
/*LUAT_LISTAGE*/T6 r141est_equivalent(T141* C,T0* a1);
/*LUAT_LISTAGE*/T2 r141nb_ligne_commentaire(T141* C);
/*LUAT_LISTAGE*/void r141afficher(T141* C,T0* a1);
/*TEXT_FILE_WRITE*/void r144filtered_put_character(T144* C,T3 a1);
/*TEXT_FILE_WRITE*/void r144write_buffer(T144* C);
/*TEXT_FILE_WRITE*/void r144disconnect(T144* C);
/*TEXT_FILE_WRITE*/void r144put_character(T144* C,T3 a1);
/*TEXT_FILE_WRITE*/void r144put_string(T144* C,T0* a1);
/*TEXT_FILE_WRITE*/void r144put_integer(T144* C,T11 a1);
extern T0*oBC32tmp_string;
extern int fBC32tmp_string;
/*TEXT_FILE_WRITE*/T0* r144tmp_string(void);
/*TEXT_FILE_WRITE*/void r144put_spaces(T144* C,T2 a1);
/*TEXT_FILE_WRITE*/void r144put_new_line(T144* C);
/*TEXT_FILE_WRITE*/void r144connect_to(T144* C,T0* a1);
T187*create187(void);
/*LUAT_ORDRE_LIGNE*/T6 r187est_verifie(T0* a1,T0* a2);
/*LUAT_ORDRE_LIGNE*/T2 r187trichotomie(T0* a1,T0* a2);
extern T0*oBC187ordre_source;
/*LUAT_LIGNE*/T0* r139element(T139* C,T2 a1);
/*LUAT_LIGNE*/T6 r139contient_commentaire(T139* C);
/*LUAT_LIGNE*/T6 r139contient_code(T139* C);
/*LUAT_LIGNE*/void r139fabriquer(T139* C,T0* a1);
/*LUAT_LIGNE*/void r139afficher(T139* C,T0* a1);
/*LUAT_LIGNE*/T2 r139nb_element(T139* C);
T186*create186(void);
/*LUAT_ORDRE_SOURCE*/T6 r186est_verifie(T0* a1,T0* a2);
/*LUAT_ORDRE_SOURCE*/T2 r186trichotomie(T0* a1,T0* a2);
T173*create173(void);
extern T0*oBC13std_error;
/*MACINTOSH_DIRECTORY_NOTATION*/T6 r173respects_repertory_notation(T0* a1);
/*MACINTOSH_DIRECTORY_NOTATION*/void r173crash(T173* C);
/*MACINTOSH_DIRECTORY_NOTATION*/void r173not_yet_implemented(T173* C);
/*MACINTOSH_DIRECTORY_NOTATION*/void r173spell_as_repertory(T0* a1);
/*MACINTOSH_DIRECTORY_NOTATION*/void r173to_directory_path(T0* a1);
/*MACINTOSH_DIRECTORY_NOTATION*/void r173to_absolute_path_in(T173* C,T0* a1,T0* a2);
/*MACINTOSH_DIRECTORY_NOTATION*/void r173to_subpath_with(T0* a1,T0* a2);
/*MACINTOSH_DIRECTORY_NOTATION*/T6 r173is_absolute_path(T173* C,T0* a1);
T184*create184(void);
/*CYGWIN_DIRECTORY_NOTATION*/T6 r184respects_repertory_notation(T0* a1);
/*CYGWIN_DIRECTORY_NOTATION*/void r184spell_as_repertory(T0* a1);
/*CYGWIN_DIRECTORY_NOTATION*/void r184to_directory_path(T0* a1);
/*CYGWIN_DIRECTORY_NOTATION*/void r184to_absolute_path_in(T0* a1,T0* a2);
/*CYGWIN_DIRECTORY_NOTATION*/void r184to_subpath_with(T0* a1,T0* a2);
/*CYGWIN_DIRECTORY_NOTATION*/T6 r184is_absolute_path(T0* a1);
T182*create182(void);
extern T0*oBC182tmp1;
extern int fBC182tmp1;
/*WINDOWS_DIRECTORY_NOTATION*/T0* r182tmp1(void);
extern T0*oBC182tmp2;
extern int fBC182tmp2;
/*WINDOWS_DIRECTORY_NOTATION*/T0* r182tmp2(void);
/*WINDOWS_DIRECTORY_NOTATION*/T6 r182respects_repertory_notation(T0* a1);
/*WINDOWS_DIRECTORY_NOTATION*/void r182spell_as_repertory(T0* a1);
/*WINDOWS_DIRECTORY_NOTATION*/void r182to_directory_path(T0* a1);
/*WINDOWS_DIRECTORY_NOTATION*/void r182to_absolute_path_in(T0* a1,T0* a2);
/*WINDOWS_DIRECTORY_NOTATION*/void r182to_subpath_with(T0* a1,T0* a2);
/*WINDOWS_DIRECTORY_NOTATION*/T6 r182is_absolute_path(T0* a1);
T181*create181(void);
/*AMIGA_DIRECTORY_NOTATION*/T6 r181respects_repertory_notation(T0* a1);
/*AMIGA_DIRECTORY_NOTATION*/void r181crash(T181* C);
/*AMIGA_DIRECTORY_NOTATION*/void r181not_yet_implemented(T181* C);
/*AMIGA_DIRECTORY_NOTATION*/void r181spell_as_repertory(T0* a1);
/*AMIGA_DIRECTORY_NOTATION*/void r181to_directory_path(T0* a1);
/*AMIGA_DIRECTORY_NOTATION*/void r181to_absolute_path_in(T181* C,T0* a1,T0* a2);
/*AMIGA_DIRECTORY_NOTATION*/void r181to_subpath_with(T0* a1,T0* a2);
/*AMIGA_DIRECTORY_NOTATION*/T6 r181is_absolute_path(T181* C,T0* a1);
T174*create174(void);
extern T0*oBC174tmp1;
extern int fBC174tmp1;
/*UNIX_DIRECTORY_NOTATION*/T0* r174tmp1(void);
extern T0*oBC174tmp2;
extern int fBC174tmp2;
/*UNIX_DIRECTORY_NOTATION*/T0* r174tmp2(void);
/*UNIX_DIRECTORY_NOTATION*/T6 r174respects_repertory_notation(T0* a1);
/*UNIX_DIRECTORY_NOTATION*/void r174spell_as_repertory(T0* a1);
/*UNIX_DIRECTORY_NOTATION*/void r174to_directory_path(T0* a1);
/*UNIX_DIRECTORY_NOTATION*/void r174to_absolute_path_in(T0* a1,T0* a2);
/*UNIX_DIRECTORY_NOTATION*/void r174to_subpath_with(T0* a1,T0* a2);
/*UNIX_DIRECTORY_NOTATION*/T6 r174is_absolute_path(T0* a1);
T180*create180(void);
/*OPENVMS_DIRECTORY_NOTATION*/T6 r180respects_repertory_notation(T0* a1);
/*OPENVMS_DIRECTORY_NOTATION*/void r180crash(T180* C);
/*OPENVMS_DIRECTORY_NOTATION*/void r180not_yet_implemented(T180* C);
/*OPENVMS_DIRECTORY_NOTATION*/void r180to_directory_path(T180* C,T0* a1);
/*OPENVMS_DIRECTORY_NOTATION*/void r180to_absolute_path_in(T180* C,T0* a1,T0* a2);
/*OPENVMS_DIRECTORY_NOTATION*/void r180to_subpath_with(T180* C,T0* a1,T0* a2);
/*OPENVMS_DIRECTORY_NOTATION*/T6 r180is_absolute_path(T180* C,T0* a1);
/*LUAT_FABRIQUE*/T0* r143produire_commentaire(T143* C,T0* a1);
/*LUAT_FABRIQUE*/T0* r143produire_ligne(T143* C,T0* a1);
/*LUAT_FABRIQUE*/void r143reinitialiser(T143* C);
/*LUAT_FABRIQUE*/T0* r143produire_code(T143* C,T0* a1);
/*LUAT_FABRIQUE*/void r143fabriquer(T143* C);
/*LUAT_ENTREE*/T3 r142caractere(T142* C);
/*LUAT_ENTREE*/void r142fabriquer(T142* C);
/*LUAT_ENTREE*/void r142initialiser(T142* C,T0* a1);
/*LUAT_ENTREE*/void r142terminer(T142* C);
/*LUAT_ENTREE*/void r142avancer(T142* C);
/*LUAT_SOURCE*/void r140fabriquer_code(T140* C,T0* a1);
/*LUAT_SOURCE*/void r140fabriquer_commentaire(T140* C,T0* a1);
/*LUAT_SOURCE*/void r140afficher(T140* C,T0* a1);
/*BASIC_DIRECTORY*/void r92compute_absolute_file_path_with(T0* a1);
/*BASIC_DIRECTORY*/T6 r92respects_repertory_notation(T0* a1);
/*BASIC_DIRECTORY*/void r92set_notation_using(T0* a1);
extern T0*oBC92last_entry;
extern int fBC92last_entry;
/*BASIC_DIRECTORY*/T0* r92last_entry(void);
/*BASIC_DIRECTORY*/T0* r92current_working_directory(void);
/*BASIC_DIRECTORY*/void r92spell_as_repertory(T0* a1);
/*BASIC_DIRECTORY*/T0* r92system_notation(void);
/*BASIC_DIRECTORY*/void r92read_entry(T92* C);
extern T0*oBC92system_notation_buffer;
/*BASIC_DIRECTORY*/void r92disconnect(T92* C);
/*BASIC_DIRECTORY*/void r92connect_to(T92* C,T0* a1);
T169*create169fabriquer(void);
/*LUAT_ANALYSEUR_ADA*/void r169fabriquer(T169* C);
/*LUAT_ANALYSEUR_ADA*/void r169traiter_etat_initial(T169* C);
extern T0*oBC26traducteur;
extern int fBC26traducteur;
/*LUAT_ANALYSEUR_ADA*/T0* r169traducteur(void);
/*LUAT_ANALYSEUR_ADA*/T0* r169traduire(T0* a1);
/*LUAT_ANALYSEUR_ADA*/void r169produire_commentaire(T169* C);
/*LUAT_ANALYSEUR_ADA*/void r169appliquer(T169* C,T0* a1);
/*LUAT_ANALYSEUR_ADA*/void r169debrayer_fabrique(T169* C);
/*LUAT_ANALYSEUR_ADA*/void r169desactiver_code(T169* C);
/*LUAT_ANALYSEUR_ADA*/void r169embrayer_fabrique(T169* C);
/*LUAT_ANALYSEUR_ADA*/void r169produire_ligne(T169* C);
/*LUAT_ANALYSEUR_ADA*/void r169gerer_erreur(T169* C,T0* a1);
/*LUAT_ANALYSEUR_ADA*/void r169reinitialiser(T169* C);
/*LUAT_ANALYSEUR_ADA*/void r169activer_commentaire(T169* C);
/*LUAT_ANALYSEUR_ADA*/void r169desactiver_commentaire(T169* C);
/*LUAT_ANALYSEUR_ADA*/T6 r169est_utilise_fabrique(T169* C);
/*LUAT_ANALYSEUR_ADA*/void r169produire_code(T169* C);
/*LUAT_ANALYSEUR_ADA*/T0* r169lire(T169* C,T0* a1);
/*LUAT_ANALYSEUR_ADA*/void r169activer_code(T169* C);
/*LUAT_ANALYSEUR_ADA*/void r169analyser(T169* C);
/*LUAT_ANALYSEUR_ADA*/void r169_P_99_gerer_erreur(T169* C,T0* a1);
/*LUAT_ANALYSEUR_ADA*/void r169_P_99_produire_code(T169* C);
/*LUAT_ANALYSEUR_ADA*/void r169_P_99_fabriquer(T169* C);
T168*create168fabriquer(T0* a1);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168fabriquer(T168* C,T0* a1);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168traiter_etat_initial(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/T0* r168traducteur(void);
/*LUAT_ANALYSEUR_FAMILLE_C*/T0* r168traduire(T0* a1);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168fabriquer_analyseur(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168traiter_etat_lexeme_identifiant(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168traiter_commentaire_multiligne(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168traiter_etat_apres_apostrophe(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168traiter_etat_apres_guillemets(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168produire_commentaire(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168appliquer(T168* C,T0* a1);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168debrayer_fabrique(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168desactiver_code(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168embrayer_fabrique(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168produire_ligne(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168gerer_erreur(T168* C,T0* a1);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168reinitialiser(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168activer_commentaire(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168desactiver_commentaire(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/T6 r168est_utilise_fabrique(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168produire_code(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/T0* r168lire(T168* C,T0* a1);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168activer_code(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168analyser(T168* C);
/*LUAT_ANALYSEUR_FAMILLE_C*/void r168_P_99_gerer_erreur(T168* C,T0* a1);
T167*create167fabriquer(void);
/*LUAT_ANALYSEUR_EIFFEL*/void r167fabriquer(T167* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r167traiter_etat_initial(T167* C);
/*LUAT_ANALYSEUR_EIFFEL*/T0* r167traducteur(void);
/*LUAT_ANALYSEUR_EIFFEL*/T0* r167traduire(T0* a1);
/*LUAT_ANALYSEUR_EIFFEL*/void r167produire_commentaire(T167* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r167appliquer(T167* C,T0* a1);
/*LUAT_ANALYSEUR_EIFFEL*/void r167debrayer_fabrique(T167* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r167desactiver_code(T167* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r167embrayer_fabrique(T167* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r167produire_ligne(T167* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r167gerer_erreur(T167* C,T0* a1);
/*LUAT_ANALYSEUR_EIFFEL*/void r167reinitialiser(T167* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r167activer_commentaire(T167* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r167desactiver_commentaire(T167* C);
/*LUAT_ANALYSEUR_EIFFEL*/T6 r167est_utilise_fabrique(T167* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r167produire_code(T167* C);
/*LUAT_ANALYSEUR_EIFFEL*/T0* r167lire(T167* C,T0* a1);
/*LUAT_ANALYSEUR_EIFFEL*/void r167activer_code(T167* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r167analyser(T167* C);
/*LUAT_ANALYSEUR_EIFFEL*/void r167_P_99_gerer_erreur(T167* C,T0* a1);
/*LUAT_ANALYSEUR_EIFFEL*/void r167_P_99_fabriquer(T167* C);
T166*create166(void);
/*LUAT_METRIQUE_EFFORT*/void r166copy(T166* C,T0* a1);
/*LUAT_METRIQUE_EFFORT*/T0* r166twin(T166* C);
/*LUAT_METRIQUE_EFFORT*/void r166afficher(T166* C,T0* a1);
/*LUAT_METRIQUE_EFFORT*/void r166mesurer(T166* C,T0* a1,T0* a2);
/*LUAT_METRIQUE_EFFORT*/T2 r166nb_ligne_partage(T0* a1,T0* a2);
T165*create165(void);
/*LUAT_METRIQUE_NORMALE*/void r165copy(T165* C,T0* a1);
/*LUAT_METRIQUE_NORMALE*/T0* r165twin(T165* C);
/*LUAT_METRIQUE_NORMALE*/void r165afficher(T165* C,T0* a1);
/*LUAT_METRIQUE_NORMALE*/void r165mesurer(T165* C,T0* a1,T0* a2);
/*LUAT_METRIQUE_NORMALE*/T2 r165nb_ligne_partage(T0* a1,T0* a2);
/*SYSTEM*/T0* r93get_environment_variable(T0* a1);
/*DANG_ANALYSEUR*/void r107fabriquer(T107* C);
/*DANG_ANALYSEUR*/void r107lire(T107* C,T0* a1);
/*DANG_ANALYSEUR*/T6 r107existe_association(T107* C,T0* a1,T0* a2);
/*DANG_ANALYSEUR*/void r107fermer(T107* C);
/*DANG_ANALYSEUR*/void r107ouvrir(T107* C,T0* a1);
/*DANG_ANALYSEUR*/void r107ajouter_association(T107* C,T0* a1,T0* a2);
T170*create170(void);
/*LUAT_ORDRE_SUFFIXE*/T6 r170est_verifie(T0* a1,T0* a2);
/*LUAT_ORDRE_SUFFIXE*/T2 r170trichotomie(T0* a1,T0* a2);
/*LUAT_SUFFIXE*/void r96fabriquer(T96* C,T0* a1,T0* a2);
/*STD_OUTPUT*/void r49filtered_flush(T49* C);
/*STD_OUTPUT*/void r49filtered_put_character(T49* C,T3 a1);
extern T0*oBC13std_output;
extern int fBC13std_output;
/*STD_OUTPUT*/T0* r49std_output(void);
/*STD_OUTPUT*/void r49make(T49* C);
/*STD_OUTPUT*/void r49se_atexit(void);
/*STD_OUTPUT*/void r49write_buffer(T49* C);
/*STD_OUTPUT*/void r49put_boolean(T49* C,T6 a1);
/*STD_OUTPUT*/void r49put_character(T49* C,T3 a1);
/*STD_OUTPUT*/void r49flush(T49* C);
/*STD_OUTPUT*/void r49put_string(T49* C,T0* a1);
/*STD_OUTPUT*/void r49put_integer(T49* C,T11 a1);
/*STD_OUTPUT*/T0* r49tmp_string(void);
/*STD_OUTPUT*/void r49put_spaces(T49* C,T2 a1);
/*STD_OUTPUT*/void r49put_new_line(T49* C);
/*LUAT_LOT_ARBRE*/void r118fabriquer(T118* C,T0* a1,T6 a2);
/*LUAT_LOT_ARBRE*/void r118lire(T118* C);
/*LUAT_LOT_ARBRE*/T0* r118traducteur(void);
/*LUAT_LOT_ARBRE*/void r118clore(T118* C);
/*LUAT_LOT_ARBRE*/void r118lister_fichier(T118* C,T0* a1);
/*LUAT_COMMANDE_DIFFERENTIEL*/T0* r117std_output(void);
/*LUAT_COMMANDE_DIFFERENTIEL*/void r117fabriquer(T117* C,T0* a1,T0* a2,T0* a3);
extern T0*oBC26configuration;
extern int fBC26configuration;
/*LUAT_COMMANDE_DIFFERENTIEL*/T0* r117configuration(void);
/*LUAT_COMMANDE_DIFFERENTIEL*/void r117executer(T117* C);
/*LUAT_COMMANDE_DIFFERENTIEL*/T6 r117sont_equivalents(T0* a1,T0* a2);
/*LUAT_COMMANDE_UNITAIRE*/T0* r116std_output(void);
/*LUAT_COMMANDE_UNITAIRE*/void r116fabriquer(T116* C,T0* a1,T0* a2);
/*LUAT_COMMANDE_UNITAIRE*/T0* r116configuration(void);
/*LUAT_COMMANDE_UNITAIRE*/void r116executer(T116* C);
/*LUAT_LOT_LISTE*/void r115fabriquer(T115* C,T0* a1);
/*LUAT_LOT_LISTE*/void r115lire(T115* C);
/*LUAT_LOT_LISTE*/void r115clore(T115* C);
/*LUAT_LOT_LISTE*/T6 r115est_epuise(T115* C);
/*LUAT_LOT_LISTE*/T0* r115entree_courte(T115* C);
/*TEXT_FILE_READ*/void r73read_available_in(T73* C,T0* a1,T2 a2);
/*TEXT_FILE_READ*/void r73read_line(T73* C);
extern T0*oBC46last_string;
extern int fBC46last_string;
/*TEXT_FILE_READ*/T0* r73last_string(void);
/*TEXT_FILE_READ*/void r73filtered_read_line_in(T73* C,T0* a1);
/*TEXT_FILE_READ*/void r73filtered_read_available_in(T73* C,T0* a1,T2 a2);
/*TEXT_FILE_READ*/void r73filtered_read_character(T73* C);
/*TEXT_FILE_READ*/void r73disconnect(T73* C);
/*TEXT_FILE_READ*/void r73fill_buffer(T73* C);
/*TEXT_FILE_READ*/void r73connect_to(T73* C,T0* a1);
/*TEXT_FILE_READ*/void r73read_line_in(T73* C,T0* a1);
/*DIRECTORY*/void r112make(T112* C);
/*DIRECTORY*/T2 r112upper(T112* C);
/*DIRECTORY*/void r112scan(T112* C,T0* a1);
/*DIRECTORY*/void r112init(T112* C,T2 a1);
/*LUAT_COMMANDE_ANALYSE*/void r110fabriquer(T110* C,T0* a1,T0* a2);
/*LUAT_COMMANDE_ANALYSE*/T0* r110configuration(void);
/*LUAT_COMMANDE_ANALYSE*/T0* r110traducteur(void);
/*LUAT_COMMANDE_ANALYSE*/void r110executer(T110* C);
T171*create171(void);
/*LUAT_COMMANDE_CONFIGURATION*/T0* r171configuration(void);
/*LUAT_COMMANDE_CONFIGURATION*/void r171executer(void);
/*LUAT_CONFIGURATION*/T0* r57std_output(void);
/*LUAT_CONFIGURATION*/void r57fabriquer(T57* C);
/*LUAT_CONFIGURATION*/void r57ajouter(T57* C,T0* a1,T0* a2,T0* a3);
/*LUAT_CONFIGURATION*/void r57traiter_erreur(T0* a1);
/*LUAT_CONFIGURATION*/void r57imposer(T57* C,T0* a1,T0* a2,T0* a3);
/*LUAT_CONFIGURATION*/void r57retirer(T57* C,T0* a1,T0* a2,T0* a3);
/*LUAT_CONFIGURATION*/void r57appliquer_choix_fichier(T57* C);
extern T0*oBC57analyseur_eiffel;
extern int fBC57analyseur_eiffel;
/*LUAT_CONFIGURATION*/T0* r57analyseur_eiffel(void);
/*LUAT_CONFIGURATION*/void r57ajouter_filtre(T0* a1,T0* a2);
extern T0*oBC57analyseur_ada;
extern int fBC57analyseur_ada;
/*LUAT_CONFIGURATION*/T0* r57analyseur_ada(void);
extern T0*oBC57analyseurs;
extern int fBC57analyseurs;
/*LUAT_CONFIGURATION*/T0* r57analyseurs(void);
/*LUAT_CONFIGURATION*/T0* r57trouver_analyseur(T0* a1);
extern T0*oBC57analyseur_c;
extern int fBC57analyseur_c;
/*LUAT_CONFIGURATION*/T0* r57analyseur_c(void);
extern T0*oBC57analyseur_c_plus_plus;
extern int fBC57analyseur_c_plus_plus;
/*LUAT_CONFIGURATION*/T0* r57analyseur_c_plus_plus(void);
/*LUAT_CONFIGURATION*/T2 r57trouver_element_configurable(T0* a1,T0* a2);
extern T0*oBC57metriques;
extern int fBC57metriques;
/*LUAT_CONFIGURATION*/T0* r57metriques(void);
/*LUAT_CONFIGURATION*/void r57retirer_filtre(T0* a1,T0* a2);
/*LUAT_CONFIGURATION*/void r57imposer_filtre(T0* a1,T0* a2);
/*LUAT_CONFIGURATION*/T6 r57forcer_analyseur(T57* C,T0* a1);
/*LUAT_CONFIGURATION*/T0* r57traducteur(void);
/*LUAT_CONFIGURATION*/T6 r57forcer_metrique(T57* C,T0* a1);
/*LUAT_CONFIGURATION*/T0* r57trouver_metrique(T0* a1);
extern T0*oBC57nom_fichier_configuration;
extern int fBC57nom_fichier_configuration;
/*LUAT_CONFIGURATION*/T0* r57nom_fichier_configuration(void);
/*LUAT_CONFIGURATION*/void r57afficher(T57* C);
/*LUAT_CONFIGURATION*/T0* r57analyseur(T57* C,T0* a1);
/*LUAT_CONFIGURATION*/void r57appliquer_choix_initial(T57* C);
/*LUAT_CONFIGURATION*/void r57afficher_filtre(T0* a1,T0* a2);
extern T0*oBC57metrique_normal;
extern int fBC57metrique_normal;
/*LUAT_CONFIGURATION*/T0* r57metrique_normal(void);
/*LUAT_FILTRE*/void r100copy(T100* C,T0* a1);
/*LUAT_FILTRE*/T6 r100choix_est_effectue(T100* C);
/*LUAT_FILTRE*/void r100met(T100* C,T6 a1,T6 a2,T6 a3);
/*LUAT_FILTRE*/void r100initialiser(T100* C);
/*LUAT_FILTRE*/T0* r100twin(T100* C);
/*LUAT_FILTRE*/T6 r100choix_est_unique(T100* C);
/*LUAT_TRADUCTEUR*/void r51init_in_default_directory(T51* C);
/*LUAT_TRADUCTEUR*/void r51set_text_domain(void);
/*LUAT_TRADUCTEUR*/void r51bind_text_domain(T0* a1,T0* a2);
/*LUAT_TRADUCTEUR*/void r51fabriquer(T51* C);
/*LUAT_TRADUCTEUR*/T0* r51traduire(T0* a1);
/*LUAT_TRADUCTEUR*/void r51register_domain(T51* C,T0* a1);
/*LUAT_TRADUCTEUR*/void r51set_default_message_locale(void);
/*LUAT_TRADUCTEUR*/void r51_P_53_init(T51* C);
/*STD_ERROR*/void r39filtered_flush(void);
/*STD_ERROR*/T0* r39std_output(void);
/*STD_ERROR*/void r39put_string(T0* a1);
/*STD_ERROR*/void r39put_spaces(T2 a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r66fabriquer(T66* C);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T0* r66configuration(void);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T0* r66traducteur(void);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T2 r66argument_count(void);
extern T0*oBC27command_arguments;
extern int fBC27command_arguments;
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T0* r66command_arguments(void);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r66produire_arbre_commande_differentiel(T66* C,T0* a1,T0* a2);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r66produire_liste_commande_unitaire(T66* C,T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T0* r66ouvrir_arbre(T0* a1,T6 a2);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r66produire_commande_differentiel(T66* C,T0* a1,T0* a2);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r66produire_lot_commande_unitaire(T66* C,T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r66produire_lot_commande_differentiel(T66* C,T0* a1,T0* a2);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r66usage(void);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r66produire_commande_unitaire(T66* C,T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r66produire_liste_commande_analyse(T66* C,T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T0* r66ouvrir_liste(T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T2 r66comparer(T0* a1,T0* a2);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r66produire_arbre_commande_unitaire(T66* C,T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/T6 r66est_repertoire(T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r66afficher_erreur(T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r66produire_lot_commande_analyse(T66* C,T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r66produire_arbre_commande_analyse(T66* C,T0* a1);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r66analyser(T66* C);
/*LUAT_LIGNE_COMMANDE_ANALYSEUR*/void r66produire_commande_analyse(T66* C,T0* a1);
typedef struct _se_agenT25C25l46c33 se_agenT25C25l46c33;
struct _se_agenT25C25l46c33{Tid id;
int creation_mold_id;
void(*afp)(se_agenT25C25l46c33*,T0*);
void(*gc_mark_agent_mold)(se_agenT25C25l46c33*);
int (*eq)(se_agent*,se_agent*);
};
typedef struct _se_agent_eq_r109executer se_agent_eq_r109executer;
struct _se_agent_eq_r109executer{Tid id;
int creation_mold_id;
void*afp;
void*gc_mark_agent_mold;
void*eq;
};
/*agent creation*/T0*agenT25C25l46c33(void);
void gc_mark_agenT25C25l46c33(se_agenT25C25l46c33*u);
/*agent equality*/int eq_agent_eq_r109executer(se_agent*u1, se_agent*u2);
/*LUAT_CODEMETRE*/T0* r25traducteur(void);
/*LUAT_CODEMETRE*/void r25principal(void);
/*LUAT_CODEMETRE*/void r25afficher_mention_legale(void);
void agent_launcher_LUAT_COMMANDE(/*agent*/T0*a,T0* a1);
union _se_agent{T0 s0;se_agent0 u0;
se_agenT25C25l46c33 uagenT25C25l46c33;
};
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#define SE_AGENTS 1
#define EIF_AGENT se_agent*

se_agent* new_agent(Tid id);

#ifdef SE_GC_LIB

  typedef struct B_agent gc_agent;

  struct B_agent {
    se_agent object;
    union {
      void *flag;
      gc_agent *next;
    } header;
  };

  extern gc_agent *store_agent;
  extern gc_agent *gc_free_agent;
  extern int       store_left_agent;
  extern fsoc     *store_chunk_agent;
  extern fsoc      H_agent;
  extern int       gc_info_nb_agent;

  void gc_align_mark_agent(fsoc *c, gc_agent* a);
  void gc_sweep_agent(fsoc *c);

#endif
extern T0*ms167_1187496964;
extern T0*ms118_46;
extern T0*ms57_2022577931;
extern T0*ms167_1283315574;
extern T0*ms25_866438147;
extern T0*ms57_78651488;
extern T0*ms6_59251;
extern T0*ms57_1326235;
extern T0*ms117_363254;
extern T0*ms118_276;
extern T0*ms57_1872750;
extern T0*ms57_1636333591bc57;
extern T0*ms179_1182938696;
extern T0*ms66_1293198338;
extern T0*ms118_46bc183;
extern T0*ms168_155715434;
extern T0*ms110_482012695;
extern T0*ms66_1511357824bc66;
extern T0*ms178_282;
extern T0*ms6_14036bc7;
extern T0*ms57_917949021bc57c22;
extern T0*ms66_1055124467bc66;
extern T0*ms168_510417238;
extern T0*ms66_667384374;
extern T0*ms168_2137071568;
extern T0*ms57_616531973bc57;
extern T0*ms116_200bc57;
extern T0*ms167_397163;
extern T0*ms57_1914603628;
extern T0*ms66_1209197973;
extern T0*ms26_2030253;
extern T0*ms57_155679758bc57c21;
extern T0*ms57_78651488bc57;
extern T0*ms57_917949021bc57;
extern T0*ms57_2067555065bc57;
extern T0*ms107_438530588bc107c36;
extern T0*ms57_616531973bc57c22;
extern T0*ms168_509162564;
extern T0*ms167_1077131282bc167;
extern T0*ms66_174479840;
extern T0*ms66_402629279;
extern T0*ms169_727364563;
extern T0*ms167_1632850237bc167;
extern T0*ms66_452763;
extern T0*ms57_89868;
extern T0*ms141_21314053;
extern T0*ms167_1632850237;
extern T0*ms57_1148145250;
extern T0*ms57_917949021;
extern T0*ms168_806032802;
extern T0*ms107_1933550935;
extern T0*ms66_1652658481;
extern T0*ms57_2067555065;
extern T0*ms25_1787719185;
extern T0*ms116_22393487;
extern T0*ms57_1022;
extern T0*ms57_207;
extern T0*ms57_99;
extern T0*ms57_252;
extern T0*ms57_331;
extern T0*ms57_329;
extern T0*ms57_334;
extern T0*ms57_778583985;
extern T0*ms57_297;
extern T0*ms165_357;
extern T0*ms66_1511357824bc66c25;
extern T0*ms165_422;
extern T0*ms165_367;
extern T0*ms57_1347;
extern T0*ms167_2094708289;
extern T0*ms167_2117014773;
extern T0*ms57_1744;
extern T0*ms57_1774;
extern T0*ms57_215549874bc57;
extern T0*ms169_141014885;
extern T0*ms57_72793912;
extern T0*ms166_1477962;
extern T0*ms66_363423546;
extern T0*ms57_778583985bc57c21;
extern T0*ms57_1945510587;
extern T0*ms57_11429;
extern T0*ms57_1581702901bc57;
extern T0*ms167_896478796bc167;
extern T0*ms167_896478796bc168;
extern T0*ms167_896478796bc169;
extern T0*ms167_1283315574bc167c22;
extern T0*ms66_1426;
extern T0*ms57_2733;
extern T0*ms117_1159bc117;
extern T0*ms57_338767662;
extern T0*ms57_2068456806;
extern T0*ms167_2117014773bc167;
extern T0*ms169_727364563bc169;
extern T0*ms167_238286578;
extern T0*ms66_1209197973bc57;
extern T0*ms169_3022;
extern T0*ms167_633654814;
extern T0*ms168_2126858037;
extern T0*ms169_953440447;
extern T0*ms57_5787;
extern T0*ms140_166353;
extern T0*ms57_252bc57;
extern T0*ms118_7613394;
extern T0*ms26_0;
extern T0*ms57_15751;
extern T0*ms99_250303104;
extern T0*ms57_1978691;
extern T0*ms169_10797639;
extern T0*ms66_955293794;
extern T0*ms57_9022;
extern T0*ms57_27714646bc57c22;
extern T0*ms57_8773;
extern T0*ms57_8790;
extern T0*ms107_1519585192;
extern T0*ms168_39279407;
extern T0*ms99_1122;
extern T0*ms57_8897;
extern T0*ms110_689122201;
extern T0*ms57_778583985bc57;
extern T0*ms6_59251bc7;
extern T0*ms167_896478796;
extern T0*ms140_134522190;
extern T0*ms57_70779537;
extern T0*ms167_1077131282;
extern T0*ms107_402183751bc107;
extern T0*ms107_402183751bc167;
extern T0*ms66_1206126564;
extern T0*ms66_667384374bc66;
extern T0*ms57_1402518293;
extern T0*ms168_198117854;
extern T0*ms169_1594537947;
extern T0*ms6_14036;
extern T0*ms167_1632850237bc167c22l411;
extern T0*ms66_659784771;
extern T0*ms169_998148855;
extern T0*ms116_178787;
extern T0*ms66_1489194569bc57;
extern T0*ms57_27714646bc57;
extern T0*ms169_128695907;
extern T0*ms117_1871339;
extern T0*ms167_1632850237bc167c21;
extern T0*ms167_1632850237bc167c22;
extern T0*ms57_1402518293bc57;
extern T0*ms66_1293198338bc66;
extern T0*ms167_1750975282;
extern T0*ms57_1387148262;
extern T0*ms167_1882109223;
extern T0*ms66_1489194569;
extern T0*ms66_1055124467;
extern T0*ms66_105509483;
extern T0*ms57_1130825850;
extern T0*ms57_1308013269;
extern T0*ms57_1815775;
extern T0*ms110_482012695bc99c38;
extern T0*ms117_1159;
extern T0*ms168_1760805737bc168;
extern T0*ms167_302894533;
extern T0*ms66_356856294;
extern T0*ms167_1632850237bc167c21l430;
extern T0*ms66_575269952;
extern T0*ms57_215549874;
extern T0*ms66_1511357824;
extern T0*ms107_881684455;
extern T0*ms57_465093820bc57;
extern T0*ms6_14036bc7c15;
extern T0*ms118_276bc183;
extern T0*ms118_276bc178;
extern T0*ms66_322;
extern T0*ms26_0bc167;
extern T0*ms26_0bc168;
extern T0*ms26_0bc169;
extern T0*ms66_1679497459;
extern T0*ms66_177674639;
extern T0*ms167_2038230808;
extern T0*ms167_2094708289bc167c21;
extern T0*ms51_49306196;
extern T0*ms167_1835982646;
extern T0*ms66_184721825;
extern T0*ms57_155679758;
extern T0*ms25_1860139408;
extern T0*ms117_45440454;
extern T0*ms26_0bc52;
extern T0*ms165_430693;
extern T0*ms26_0bc92;
extern T0*ms167_896478796bc169c21;
extern T0*ms167_156993542;
extern T0*ms66_1823520895;
extern T0*ms66_494198994;
extern T0*ms116_949372;
extern T0*ms107_438530588bc107;
extern T0*ms66_558072449;
extern T0*ms167_896478796bc168c19;
extern T0*ms116_200bc117;
extern T0*ms57_20654818;
extern T0*ms110_139149946;
extern T0*ms26_0bc52c9;
extern T0*ms167_2094708289bc167;
extern T0*ms107_438530588;
extern T0*ms167_1283315574bc167;
extern T0*ms57_252bc57c31;
extern T0*ms169_619685758;
extern T0*ms118_1839491374;
extern T0*ms116_200;
extern T0*ms168_1760805737;
extern T0*ms167_613991936;
extern T0*ms66_45085;
extern T0*ms107_402183751bc107c36;
extern T0*ms141_190;
extern T0*ms166_395586;
extern T0*ms169_1916976;
extern T0*ms57_1636333591;
extern T0*ms66_2038516345;
extern T0*ms169_935023928;
extern T0*ms57_1581702901;
extern T0*ms66_482439428;
extern T0*ms168_276953473;
extern T0*ms57_27714646;
extern T0*ms167_1187496964bc167;
extern T0*ms66_1196995941;
extern T0*ms66_709525889;
extern T0*ms107_402183751bc107c36l170;
extern T0*ms57_616531973;
extern T0*ms66_1689211819;
extern T0*ms117_237;
extern T0*ms167_249419393;
extern T0*ms117_497;
extern T0*ms110_482012695bc99;
extern T0*ms99_1469960689;
extern T0*ms57_155679758bc57;
extern T0*ms57_1581702901bc57c22;
extern T0*ms99_83912;
extern T0*ms167_302894533bc169;
extern T0*ms66_45085bc66;
extern T0*ms116_41;
extern T0*ms57_465093820;
extern T0*ms167_249419393bc168;
extern T0*ms167_249419393bc169;
extern T0*ms167_1882109223bc168;
extern T0*ms167_1882109223bc169;
extern T0*ms107_1655531153;
extern T0*ms107_402183751;
extern T0*ms167_249419393bc168c19;
T0*se_ms(int c,char*e);
T0*se_string(char*e);
void se_msi1(void);
void se_msi2(void);
void se_msi3(void);
void se_msi4(void);
void se_msi5(void);
void manifest_string_mark1(void);
void once_function_mark(void);
void gc_start(void);
extern na_env na_env234;
typedef struct B233 gc233;
struct B233{T233 object;union {void*flag;gc233*next;} header;};
extern gc233*store233;
extern int store_left233;
extern fsoc*store_chunk233;
extern gc233*gc_free233;
typedef struct B232 gc232;
struct B232{T232 object;union {void*flag;gc232*next;} header;};
extern gc232*store232;
extern int store_left232;
extern fsoc*store_chunk232;
extern gc232*gc_free232;
extern na_env na_env231;
typedef struct B72 gc72;
struct B72{T72 object;union {void*flag;gc72*next;} header;};
extern gc72*store72;
extern int store_left72;
extern fsoc*store_chunk72;
extern gc72*gc_free72;
typedef struct B230 gc230;
struct B230{T230 object;union {void*flag;gc230*next;} header;};
extern gc230*store230;
extern int store_left230;
extern fsoc*store_chunk230;
extern gc230*gc_free230;
extern na_env na_env228;
typedef struct B226 gc226;
struct B226{T226 object;union {void*flag;gc226*next;} header;};
extern gc226*store226;
extern int store_left226;
extern fsoc*store_chunk226;
extern gc226*gc_free226;
typedef struct B183 gc183;
struct B183{T183 object;union {void*flag;gc183*next;} header;};
extern gc183*store183;
extern int store_left183;
extern fsoc*store_chunk183;
extern gc183*gc_free183;
typedef struct B178 gc178;
struct B178{T178 object;union {void*flag;gc178*next;} header;};
extern gc178*store178;
extern int store_left178;
extern fsoc*store_chunk178;
extern gc178*gc_free178;
typedef struct B141 gc141;
struct B141{T141 object;union {void*flag;gc141*next;} header;};
extern gc141*store141;
extern int store_left141;
extern fsoc*store_chunk141;
extern gc141*gc_free141;
typedef struct B144 gc144;
struct B144{T144 object;union {void*flag;gc144*next;} header;};
extern gc144*store144;
extern int store_left144;
extern fsoc*store_chunk144;
extern gc144*gc_free144;
extern na_env na_env224;
extern na_env na_env223;
typedef struct B222 gc222;
struct B222{T222 object;union {void*flag;gc222*next;} header;};
extern gc222*store222;
extern int store_left222;
extern fsoc*store_chunk222;
extern gc222*gc_free222;
typedef struct B221 gc221;
struct B221{T221 object;union {void*flag;gc221*next;} header;};
extern gc221*store221;
extern int store_left221;
extern fsoc*store_chunk221;
extern gc221*gc_free221;
typedef struct B220 gc220;
struct B220{T220 object;union {void*flag;gc220*next;} header;};
extern gc220*store220;
extern int store_left220;
extern fsoc*store_chunk220;
extern gc220*gc_free220;
typedef struct B219 gc219;
struct B219{T219 object;union {void*flag;gc219*next;} header;};
extern gc219*store219;
extern int store_left219;
extern fsoc*store_chunk219;
extern gc219*gc_free219;
typedef struct B218 gc218;
struct B218{T218 object;union {void*flag;gc218*next;} header;};
extern gc218*store218;
extern int store_left218;
extern fsoc*store_chunk218;
extern gc218*gc_free218;
typedef struct B217 gc217;
struct B217{T217 object;union {void*flag;gc217*next;} header;};
extern gc217*store217;
extern int store_left217;
extern fsoc*store_chunk217;
extern gc217*gc_free217;
typedef struct B187 gc187;
struct B187{T187 object;union {void*flag;gc187*next;} header;};
extern gc187*store187;
extern int store_left187;
extern fsoc*store_chunk187;
extern gc187*gc_free187;
typedef struct B139 gc139;
struct B139{T139 object;union {void*flag;gc139*next;} header;};
extern gc139*store139;
extern int store_left139;
extern fsoc*store_chunk139;
extern gc139*gc_free139;
typedef struct B215 gc215;
struct B215{T215 object;union {void*flag;gc215*next;} header;};
extern gc215*store215;
extern int store_left215;
extern fsoc*store_chunk215;
extern gc215*gc_free215;
typedef struct B186 gc186;
struct B186{T186 object;union {void*flag;gc186*next;} header;};
extern gc186*store186;
extern int store_left186;
extern fsoc*store_chunk186;
extern gc186*gc_free186;
typedef struct B213 gc213;
struct B213{T213 object;union {void*flag;gc213*next;} header;};
extern gc213*store213;
extern int store_left213;
extern fsoc*store_chunk213;
extern gc213*gc_free213;
extern na_env na_env212;
extern na_env na_env211;
typedef struct B154 gc154;
struct B154{T154 object;union {void*flag;gc154*next;} header;};
extern gc154*store154;
extern int store_left154;
extern fsoc*store_chunk154;
extern gc154*gc_free154;
extern na_env na_env210;
typedef struct B173 gc173;
struct B173{T173 object;union {void*flag;gc173*next;} header;};
extern gc173*store173;
extern int store_left173;
extern fsoc*store_chunk173;
extern gc173*gc_free173;
typedef struct B184 gc184;
struct B184{T184 object;union {void*flag;gc184*next;} header;};
extern gc184*store184;
extern int store_left184;
extern fsoc*store_chunk184;
extern gc184*gc_free184;
typedef struct B182 gc182;
struct B182{T182 object;union {void*flag;gc182*next;} header;};
extern gc182*store182;
extern int store_left182;
extern fsoc*store_chunk182;
extern gc182*gc_free182;
typedef struct B181 gc181;
struct B181{T181 object;union {void*flag;gc181*next;} header;};
extern gc181*store181;
extern int store_left181;
extern fsoc*store_chunk181;
extern gc181*gc_free181;
typedef struct B174 gc174;
struct B174{T174 object;union {void*flag;gc174*next;} header;};
extern gc174*store174;
extern int store_left174;
extern fsoc*store_chunk174;
extern gc174*gc_free174;
typedef struct B180 gc180;
struct B180{T180 object;union {void*flag;gc180*next;} header;};
extern gc180*store180;
extern int store_left180;
extern fsoc*store_chunk180;
extern gc180*gc_free180;
typedef struct B209 gc209;
struct B209{T209 object;union {void*flag;gc209*next;} header;};
extern gc209*store209;
extern int store_left209;
extern fsoc*store_chunk209;
extern gc209*gc_free209;
typedef struct B143 gc143;
struct B143{T143 object;union {void*flag;gc143*next;} header;};
extern gc143*store143;
extern int store_left143;
extern fsoc*store_chunk143;
extern gc143*gc_free143;
typedef struct B142 gc142;
struct B142{T142 object;union {void*flag;gc142*next;} header;};
extern gc142*store142;
extern int store_left142;
extern fsoc*store_chunk142;
extern gc142*gc_free142;
typedef struct B140 gc140;
struct B140{T140 object;union {void*flag;gc140*next;} header;};
extern gc140*store140;
extern int store_left140;
extern fsoc*store_chunk140;
extern gc140*gc_free140;
typedef struct B208 gc208;
struct B208{T208 object;union {void*flag;gc208*next;} header;};
extern gc208*store208;
extern int store_left208;
extern fsoc*store_chunk208;
extern gc208*gc_free208;
extern na_env na_env207;
extern na_env na_env206;
typedef struct B205 gc205;
struct B205{T205 object;union {void*flag;gc205*next;} header;};
extern gc205*store205;
extern int store_left205;
extern fsoc*store_chunk205;
extern gc205*gc_free205;
typedef struct B204 gc204;
struct B204{T204 object;union {void*flag;gc204*next;} header;};
extern gc204*store204;
extern int store_left204;
extern fsoc*store_chunk204;
extern gc204*gc_free204;
typedef struct B203 gc203;
struct B203{T203 object;union {void*flag;gc203*next;} header;};
extern gc203*store203;
extern int store_left203;
extern fsoc*store_chunk203;
extern gc203*gc_free203;
typedef struct B202 gc202;
struct B202{T202 object;union {void*flag;gc202*next;} header;};
extern gc202*store202;
extern int store_left202;
extern fsoc*store_chunk202;
extern gc202*gc_free202;
extern na_env na_env201;
typedef struct B169 gc169;
struct B169{T169 object;union {void*flag;gc169*next;} header;};
extern gc169*store169;
extern int store_left169;
extern fsoc*store_chunk169;
extern gc169*gc_free169;
typedef struct B168 gc168;
struct B168{T168 object;union {void*flag;gc168*next;} header;};
extern gc168*store168;
extern int store_left168;
extern fsoc*store_chunk168;
extern gc168*gc_free168;
typedef struct B167 gc167;
struct B167{T167 object;union {void*flag;gc167*next;} header;};
extern gc167*store167;
extern int store_left167;
extern fsoc*store_chunk167;
extern gc167*gc_free167;
typedef struct B198 gc198;
struct B198{T198 object;union {void*flag;gc198*next;} header;};
extern gc198*store198;
extern int store_left198;
extern fsoc*store_chunk198;
extern gc198*gc_free198;
typedef struct B166 gc166;
struct B166{T166 object;union {void*flag;gc166*next;} header;};
extern gc166*store166;
extern int store_left166;
extern fsoc*store_chunk166;
extern gc166*gc_free166;
typedef struct B165 gc165;
struct B165{T165 object;union {void*flag;gc165*next;} header;};
extern gc165*store165;
extern int store_left165;
extern fsoc*store_chunk165;
extern gc165*gc_free165;
typedef struct B196 gc196;
struct B196{T196 object;union {void*flag;gc196*next;} header;};
extern gc196*store196;
extern int store_left196;
extern fsoc*store_chunk196;
extern gc196*gc_free196;
typedef struct B195 gc195;
struct B195{T195 object;union {void*flag;gc195*next;} header;};
extern gc195*store195;
extern int store_left195;
extern fsoc*store_chunk195;
extern gc195*gc_free195;
typedef struct B107 gc107;
struct B107{T107 object;union {void*flag;gc107*next;} header;};
extern gc107*store107;
extern int store_left107;
extern fsoc*store_chunk107;
extern gc107*gc_free107;
typedef struct B170 gc170;
struct B170{T170 object;union {void*flag;gc170*next;} header;};
extern gc170*store170;
extern int store_left170;
extern fsoc*store_chunk170;
extern gc170*gc_free170;
typedef struct B96 gc96;
struct B96{T96 object;union {void*flag;gc96*next;} header;};
extern gc96*store96;
extern int store_left96;
extern fsoc*store_chunk96;
extern gc96*gc_free96;
typedef struct B193 gc193;
struct B193{T193 object;union {void*flag;gc193*next;} header;};
extern gc193*store193;
extern int store_left193;
extern fsoc*store_chunk193;
extern gc193*gc_free193;
typedef struct B49 gc49;
struct B49{T49 object;union {void*flag;gc49*next;} header;};
extern gc49*store49;
extern int store_left49;
extern fsoc*store_chunk49;
extern gc49*gc_free49;
extern na_env na_env192;
typedef struct B191 gc191;
struct B191{T191 object;union {void*flag;gc191*next;} header;};
extern gc191*store191;
extern int store_left191;
extern fsoc*store_chunk191;
extern gc191*gc_free191;
typedef struct B118 gc118;
struct B118{T118 object;union {void*flag;gc118*next;} header;};
extern gc118*store118;
extern int store_left118;
extern fsoc*store_chunk118;
extern gc118*gc_free118;
typedef struct B117 gc117;
struct B117{T117 object;union {void*flag;gc117*next;} header;};
extern gc117*store117;
extern int store_left117;
extern fsoc*store_chunk117;
extern gc117*gc_free117;
typedef struct B116 gc116;
struct B116{T116 object;union {void*flag;gc116*next;} header;};
extern gc116*store116;
extern int store_left116;
extern fsoc*store_chunk116;
extern gc116*gc_free116;
typedef struct B115 gc115;
struct B115{T115 object;union {void*flag;gc115*next;} header;};
extern gc115*store115;
extern int store_left115;
extern fsoc*store_chunk115;
extern gc115*gc_free115;
typedef struct B73 gc73;
struct B73{T73 object;union {void*flag;gc73*next;} header;};
extern gc73*store73;
extern int store_left73;
extern fsoc*store_chunk73;
extern gc73*gc_free73;
typedef struct B114 gc114;
struct B114{T114 object;union {void*flag;gc114*next;} header;};
extern gc114*store114;
extern int store_left114;
extern fsoc*store_chunk114;
extern gc114*gc_free114;
typedef struct B112 gc112;
struct B112{T112 object;union {void*flag;gc112*next;} header;};
extern gc112*store112;
extern int store_left112;
extern fsoc*store_chunk112;
extern gc112*gc_free112;
typedef struct B110 gc110;
struct B110{T110 object;union {void*flag;gc110*next;} header;};
extern gc110*store110;
extern int store_left110;
extern fsoc*store_chunk110;
extern gc110*gc_free110;
typedef struct B171 gc171;
struct B171{T171 object;union {void*flag;gc171*next;} header;};
extern gc171*store171;
extern int store_left171;
extern fsoc*store_chunk171;
extern gc171*gc_free171;
typedef struct B57 gc57;
struct B57{T57 object;union {void*flag;gc57*next;} header;};
extern gc57*store57;
extern int store_left57;
extern fsoc*store_chunk57;
extern gc57*gc_free57;
typedef struct B100 gc100;
struct B100{T100 object;union {void*flag;gc100*next;} header;};
extern gc100*store100;
extern int store_left100;
extern fsoc*store_chunk100;
extern gc100*gc_free100;
typedef struct B51 gc51;
struct B51{T51 object;union {void*flag;gc51*next;} header;};
extern gc51*store51;
extern int store_left51;
extern fsoc*store_chunk51;
extern gc51*gc_free51;
extern na_env na_env9;
typedef struct B7 gc7;
struct B7{T7 object;union {void*flag;gc7*next;} header;};
extern gc7*store7;
extern int store_left7;
extern fsoc*store_chunk7;
extern gc7*gc_free7;
typedef struct B39 gc39;
struct B39{T39 object;union {void*flag;gc39*next;} header;};
extern gc39*store39;
extern int store_left39;
extern fsoc*store_chunk39;
extern gc39*gc_free39;

#define gc_mark189(x) (((se_agent0*)(x))->gc_mark_agent_mold((se_agent*)(x)))

typedef struct B188 gc188;
struct B188{T188 object;union {void*flag;gc188*next;} header;};
extern gc188*store188;
extern int store_left188;
extern fsoc*store_chunk188;
extern gc188*gc_free188;
typedef struct B66 gc66;
struct B66{T66 object;union {void*flag;gc66*next;} header;};
extern gc66*store66;
extern int store_left66;
extern fsoc*store_chunk66;
extern gc66*gc_free66;
typedef struct B25 gc25;
struct B25{T25 object;union {void*flag;gc25*next;} header;};
extern gc25*store25;
extern int store_left25;
extern fsoc*store_chunk25;
extern gc25*gc_free25;
void gc_mark234(T234 o);
T234 new234(unsigned int size);
void gc_sweep233(fsoc*c);
void gc_mark233(T233*o);
void gc_align_mark233(fsoc*c,gc233*p);
extern fsoc H233;
T233*new233(void);
void gc_sweep232(fsoc*c);
void gc_mark232(T232*o);
void gc_align_mark232(fsoc*c,gc232*p);
extern fsoc H232;
T232*new232(void);
void gc_mark231(T231 o);
T231 new231(unsigned int size);
void gc_sweep72(fsoc*c);
void gc_mark72(T72*o);
void gc_align_mark72(fsoc*c,gc72*p);
extern fsoc H72;
T72*new72(void);
void gc_sweep230(fsoc*c);
void gc_mark230(T230*o);
void gc_align_mark230(fsoc*c,gc230*p);
extern fsoc H230;
T230*new230(void);
void gc_mark228(T228 o);
T228 new228(unsigned int size);
void gc_sweep226(fsoc*c);
void gc_mark226(T226*o);
void gc_align_mark226(fsoc*c,gc226*p);
extern fsoc H226;
T226*new226(void);
void gc_sweep183(fsoc*c);
void gc_mark183(T183*o);
void gc_align_mark183(fsoc*c,gc183*p);
extern fsoc H183;
T183*new183(void);
void gc_sweep178(fsoc*c);
void gc_mark178(T178*o);
void gc_align_mark178(fsoc*c,gc178*p);
extern fsoc H178;
T178*new178(void);
void gc_sweep141(fsoc*c);
void gc_mark141(T141*o);
void gc_align_mark141(fsoc*c,gc141*p);
extern fsoc H141;
T141*new141(void);
void gc_sweep144(fsoc*c);
void gc_mark144(T144*o);
void gc_align_mark144(fsoc*c,gc144*p);
extern fsoc H144;
T144*new144(void);
void gc_mark224(T224 o);
T224 new224(unsigned int size);
void gc_mark223(T223 o);
T223 new223(unsigned int size);
void gc_sweep222(fsoc*c);
void gc_mark222(T222*o);
void gc_align_mark222(fsoc*c,gc222*p);
extern fsoc H222;
T222*new222(void);
void gc_sweep221(fsoc*c);
void gc_mark221(T221*o);
void gc_align_mark221(fsoc*c,gc221*p);
extern fsoc H221;
T221*new221(void);
void gc_sweep220(fsoc*c);
void gc_mark220(T220*o);
void gc_align_mark220(fsoc*c,gc220*p);
extern fsoc H220;
T220*new220(void);
void gc_sweep219(fsoc*c);
void gc_mark219(T219*o);
void gc_align_mark219(fsoc*c,gc219*p);
extern fsoc H219;
T219*new219(void);
void gc_sweep218(fsoc*c);
void gc_mark218(T218*o);
void gc_align_mark218(fsoc*c,gc218*p);
extern fsoc H218;
T218*new218(void);
void gc_sweep217(fsoc*c);
void gc_mark217(T217*o);
void gc_align_mark217(fsoc*c,gc217*p);
extern fsoc H217;
T217*new217(void);
void gc_sweep187(fsoc*c);
void gc_mark187(T187*o);
void gc_align_mark187(fsoc*c,gc187*p);
extern fsoc H187;
T187*new187(void);
void gc_sweep139(fsoc*c);
void gc_mark139(T139*o);
void gc_align_mark139(fsoc*c,gc139*p);
extern fsoc H139;
T139*new139(void);
void gc_sweep215(fsoc*c);
void gc_mark215(T215*o);
void gc_align_mark215(fsoc*c,gc215*p);
extern fsoc H215;
T215*new215(void);
void gc_sweep186(fsoc*c);
void gc_mark186(T186*o);
void gc_align_mark186(fsoc*c,gc186*p);
extern fsoc H186;
T186*new186(void);
void gc_sweep213(fsoc*c);
void gc_mark213(T213*o);
void gc_align_mark213(fsoc*c,gc213*p);
extern fsoc H213;
T213*new213(void);
void gc_mark212(T212 o);
T212 new212(unsigned int size);
void gc_mark211(T211 o);
T211 new211(unsigned int size);
void gc_sweep154(fsoc*c);
void gc_mark154(T154*o);
void gc_align_mark154(fsoc*c,gc154*p);
extern fsoc H154;
T154*new154(void);
void gc_mark210(T210 o);
T210 new210(unsigned int size);
void gc_sweep173(fsoc*c);
void gc_mark173(T173*o);
void gc_align_mark173(fsoc*c,gc173*p);
extern fsoc H173;
T173*new173(void);
void gc_sweep184(fsoc*c);
void gc_mark184(T184*o);
void gc_align_mark184(fsoc*c,gc184*p);
extern fsoc H184;
T184*new184(void);
void gc_sweep182(fsoc*c);
void gc_mark182(T182*o);
void gc_align_mark182(fsoc*c,gc182*p);
extern fsoc H182;
T182*new182(void);
void gc_sweep181(fsoc*c);
void gc_mark181(T181*o);
void gc_align_mark181(fsoc*c,gc181*p);
extern fsoc H181;
T181*new181(void);
void gc_sweep174(fsoc*c);
void gc_mark174(T174*o);
void gc_align_mark174(fsoc*c,gc174*p);
extern fsoc H174;
T174*new174(void);
void gc_sweep180(fsoc*c);
void gc_mark180(T180*o);
void gc_align_mark180(fsoc*c,gc180*p);
extern fsoc H180;
T180*new180(void);
void gc_sweep209(fsoc*c);
void gc_mark209(T209*o);
void gc_align_mark209(fsoc*c,gc209*p);
extern fsoc H209;
T209*new209(void);
void gc_sweep143(fsoc*c);
void gc_mark143(T143*o);
void gc_align_mark143(fsoc*c,gc143*p);
extern fsoc H143;
T143*new143(void);
void gc_sweep142(fsoc*c);
void gc_mark142(T142*o);
void gc_align_mark142(fsoc*c,gc142*p);
extern fsoc H142;
T142*new142(void);
void gc_sweep140(fsoc*c);
void gc_mark140(T140*o);
void gc_align_mark140(fsoc*c,gc140*p);
extern fsoc H140;
T140*new140(void);
void gc_sweep208(fsoc*c);
void gc_mark208(T208*o);
void gc_align_mark208(fsoc*c,gc208*p);
extern fsoc H208;
T208*new208(void);
void gc_mark207(T207 o);
T207 new207(unsigned int size);
void gc_mark206(T206 o);
T206 new206(unsigned int size);
void gc_sweep205(fsoc*c);
void gc_mark205(T205*o);
void gc_align_mark205(fsoc*c,gc205*p);
extern fsoc H205;
T205*new205(void);
void gc_sweep204(fsoc*c);
void gc_mark204(T204*o);
void gc_align_mark204(fsoc*c,gc204*p);
extern fsoc H204;
T204*new204(void);
void gc_sweep203(fsoc*c);
void gc_mark203(T203*o);
void gc_align_mark203(fsoc*c,gc203*p);
extern fsoc H203;
T203*new203(void);
void gc_sweep202(fsoc*c);
void gc_mark202(T202*o);
void gc_align_mark202(fsoc*c,gc202*p);
extern fsoc H202;
T202*new202(void);
void gc_mark201(T201 o);
T201 new201(unsigned int size);
void gc_sweep169(fsoc*c);
void gc_mark169(T169*o);
void gc_align_mark169(fsoc*c,gc169*p);
extern fsoc H169;
T169*new169(void);
void gc_sweep168(fsoc*c);
void gc_mark168(T168*o);
void gc_align_mark168(fsoc*c,gc168*p);
extern fsoc H168;
T168*new168(void);
void gc_sweep167(fsoc*c);
void gc_mark167(T167*o);
void gc_align_mark167(fsoc*c,gc167*p);
extern fsoc H167;
T167*new167(void);
void gc_sweep198(fsoc*c);
void gc_mark198(T198*o);
void gc_align_mark198(fsoc*c,gc198*p);
extern fsoc H198;
T198*new198(void);
void gc_sweep166(fsoc*c);
void gc_mark166(T166*o);
void gc_align_mark166(fsoc*c,gc166*p);
extern fsoc H166;
T166*new166(void);
void gc_sweep165(fsoc*c);
void gc_mark165(T165*o);
void gc_align_mark165(fsoc*c,gc165*p);
extern fsoc H165;
T165*new165(void);
void gc_sweep196(fsoc*c);
void gc_mark196(T196*o);
void gc_align_mark196(fsoc*c,gc196*p);
extern fsoc H196;
T196*new196(void);
void gc_sweep195(fsoc*c);
void gc_mark195(T195*o);
void gc_align_mark195(fsoc*c,gc195*p);
extern fsoc H195;
T195*new195(void);
void gc_sweep107(fsoc*c);
void gc_mark107(T107*o);
void gc_align_mark107(fsoc*c,gc107*p);
extern fsoc H107;
T107*new107(void);
void gc_sweep170(fsoc*c);
void gc_mark170(T170*o);
void gc_align_mark170(fsoc*c,gc170*p);
extern fsoc H170;
T170*new170(void);
void gc_sweep96(fsoc*c);
void gc_mark96(T96*o);
void gc_align_mark96(fsoc*c,gc96*p);
extern fsoc H96;
T96*new96(void);
void gc_sweep193(fsoc*c);
void gc_mark193(T193*o);
void gc_align_mark193(fsoc*c,gc193*p);
extern fsoc H193;
T193*new193(void);
void gc_sweep49(fsoc*c);
void gc_mark49(T49*o);
void gc_align_mark49(fsoc*c,gc49*p);
extern fsoc H49;
T49*new49(void);
void gc_mark192(T192 o);
T192 new192(unsigned int size);
void gc_sweep191(fsoc*c);
void gc_mark191(T191*o);
void gc_align_mark191(fsoc*c,gc191*p);
extern fsoc H191;
T191*new191(void);
void gc_sweep118(fsoc*c);
void gc_mark118(T118*o);
void gc_align_mark118(fsoc*c,gc118*p);
extern fsoc H118;
T118*new118(void);
void gc_sweep117(fsoc*c);
void gc_mark117(T117*o);
void gc_align_mark117(fsoc*c,gc117*p);
extern fsoc H117;
T117*new117(void);
void gc_sweep116(fsoc*c);
void gc_mark116(T116*o);
void gc_align_mark116(fsoc*c,gc116*p);
extern fsoc H116;
T116*new116(void);
void gc_sweep115(fsoc*c);
void gc_mark115(T115*o);
void gc_align_mark115(fsoc*c,gc115*p);
extern fsoc H115;
T115*new115(void);
void gc_sweep73(fsoc*c);
void gc_mark73(T73*o);
void gc_align_mark73(fsoc*c,gc73*p);
extern fsoc H73;
T73*new73(void);
void gc_sweep114(fsoc*c);
void gc_mark114(T114*o);
void gc_align_mark114(fsoc*c,gc114*p);
extern fsoc H114;
T114*new114(void);
void gc_sweep112(fsoc*c);
void gc_mark112(T112*o);
void gc_align_mark112(fsoc*c,gc112*p);
extern fsoc H112;
T112*new112(void);
void gc_sweep110(fsoc*c);
void gc_mark110(T110*o);
void gc_align_mark110(fsoc*c,gc110*p);
extern fsoc H110;
T110*new110(void);
void gc_sweep171(fsoc*c);
void gc_mark171(T171*o);
void gc_align_mark171(fsoc*c,gc171*p);
extern fsoc H171;
T171*new171(void);
void gc_sweep57(fsoc*c);
void gc_mark57(T57*o);
void gc_align_mark57(fsoc*c,gc57*p);
extern fsoc H57;
T57*new57(void);
void gc_sweep100(fsoc*c);
void gc_mark100(T100*o);
void gc_align_mark100(fsoc*c,gc100*p);
extern fsoc H100;
T100*new100(void);
void gc_sweep51(fsoc*c);
void gc_mark51(T51*o);
void gc_align_mark51(fsoc*c,gc51*p);
extern fsoc H51;
T51*new51(void);
void gc_mark9(T9 o);
T9 new9(unsigned int size);
void gc_sweep7(fsoc*c);
void gc_mark7(T7*o);
void gc_align_mark7(fsoc*c,gc7*p);
extern fsoc H7;
T7*new7(void);
void gc_sweep39(fsoc*c);
void gc_mark39(T39*o);
void gc_align_mark39(fsoc*c,gc39*p);
extern fsoc H39;
T39*new39(void);
void gc_sweep188(fsoc*c);
void gc_mark188(T188*o);
void gc_align_mark188(fsoc*c,gc188*p);
extern fsoc H188;
T188*new188(void);
void gc_sweep66(fsoc*c);
void gc_mark66(T66*o);
void gc_align_mark66(fsoc*c,gc66*p);
extern fsoc H66;
T66*new66(void);
void gc_sweep25(fsoc*c);
void gc_mark25(T25*o);
void gc_align_mark25(fsoc*c,gc25*p);
extern fsoc H25;
T25*new25(void);
void Xgc_mark134(T0*o);
void Xgc_mark109(T0*o);
void Xgc_mark97(T0*o);
void Xgc_mark99(T0*o);
extern T25*eiffel_root_object;
extern int se_argc;
extern char**se_argv;
#define SE_MAXID 235
extern T7*g[];
extern T7*t[];
extern int se_strucT[];
extern T0*oBC136rouge;
extern T0*oBC136noir;
void se_atexit(void);
void initialize_eiffel_runtime(int argc,char*argv[]);
int main(int argc,char*argv[]);
void X28put_character(T0*C,T3 a1);
void X28put_string(T0*C,T0* a1);
void X28put_integer(T0*C,T11 a1);
T0* X28tmp_string(T0*C);
void X28put_spaces(T0*C,T2 a1);
void X28filtered_put_character(T0*C,T3 a1);
void X28put_new_line(T0*C);
T6 X134respects_repertory_notation(T0*C,T0* a1);
void X134to_directory_path(T0*C,T0* a1);
void X134to_absolute_path_in(T0*C,T0* a1,T0* a2);
void X134to_subpath_with(T0*C,T0* a1,T0* a2);
void X134spell_as_repertory(T0*C,T0* a1);
T6 X134is_absolute_path(T0*C,T0* a1);
T0* X99fabrique(T0*C);
void X99appliquer(T0*C,T0* a1);
T0* X99message_erreur(T0*C);
void X99debrayer_fabrique(T0*C);
T6 X99code_pris_en_compte(T0*C);
void X99desactiver_code(T0*C);
void X99embrayer_fabrique(T0*C);
T0* X99langage(T0*C);
T0* X99traducteur(T0*C);
void X99reinitialiser(T0*C);
T6 X99commentaire_pris_en_compte(T0*C);
void X99activer_commentaire(T0*C);
void X99desactiver_commentaire(T0*C);
T0* X99fichier(T0*C);
T6 X99est_utilise_fabrique(T0*C);
T0* X99listage(T0*C);
T0* X99traduire(T0*C,T0* a1);
T0* X99lire(T0*C,T0* a1);
void X99activer_code(T0*C);
void X99analyser(T0*C);
T0* X98clef(T0*C);
void X177join_to(T0*C,T0* a1);
void X109executer(T0*C);
void X97mesurer(T0*C,T0* a1,T0* a2);
T0* X97nom(T0*C);
T0* X97twin(T0*C);
void X97copy(T0*C,T0* a1);
void X97afficher(T0*C,T0* a1);
T2 X197lower(T0*C);
T2 X197upper(T0*C);
T0* X197item(T0*C,T2 a1);
T0* X111entree(T0*C);
void X111clore(T0*C);
T6 X111est_epuise(T0*C);
T0* X111entree_courte(T0*C);
void X111lire(T0*C);
void X176join_up(T0*C);
void X176start_join(T0*C,T0* a1,T2 a2);
void X176end_join(T0*C);
void X176join_element(T0*C,T0* a1);
void X176join_directory(T0*C,T0* a1);

#ifdef __cplusplus
}
#endif
